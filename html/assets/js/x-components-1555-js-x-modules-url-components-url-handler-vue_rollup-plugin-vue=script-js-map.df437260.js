(window.webpackJsonp=window.webpackJsonp||[]).push([[733],{1502:function(A,e){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"url-handler.vue_rollup-plugin-vue=script.js\",\"sources\":[\"../../../../../src/x-modules/url/components/url-handler.vue?rollup-plugin-vue=script.ts\"],\"sourcesContent\":[\"\\n\\n\\n\\n\\nimport Vue from 'vue';\\nimport GlobalEvents from 'vue-global-events';\\nimport { Component, Inject } from 'vue-property-decorator';\\nimport { XOn } from '../../../components/decorators/bus.decorators';\\nimport { xComponentMixin } from '../../../components/x-component.mixin';\\nimport { FeatureLocation } from '../../../types/origin';\\nimport { UrlParams } from '../../../types/url-params';\\nimport { isArrayEmpty } from '../../../utils/array';\\nimport { objectFilter } from '../../../utils/object';\\nimport { Dictionary } from '../../../utils/types';\\nimport { WireMetadata } from '../../../wiring/wiring.types';\\nimport { SnippetConfig } from '../../../x-installer/api/api.types';\\nimport { initialUrlState } from '../store/initial-state';\\nimport { UrlParamValue } from '../store/types';\\nimport { urlXModule } from '../x-module';\\n\\ninterface ParsedUrlParams {\\n  all: UrlParams;\\n  extra: Dictionary<unknown>;\\n}\\n\\n/**\\n * This component manage the browser URL parameters to perserve them through reloads and browser\\n * history navigation. It allow to configure the default url parameter names using its attributes.\\n * This component doesn't render elements to the DOM.\\n *\\n * @public\\n */\\n@Component({\\n  components: {\\n    GlobalEvents\\n  },\\n  mixins: [xComponentMixin(urlXModule)]\\n})\\nexport default class UrlHandler extends Vue {\\n  /**\\n   * The {@link SnippetConfig} provided by an ancestor.\\n   *\\n   * @internal\\n   */\\n  @Inject({ default: undefined })\\n  protected snippetConfig?: SnippetConfig;\\n\\n  /**\\n   * Flag to know if the params were already loaded from the URL.\\n   *\\n   * @internal\\n   */\\n  protected urlLoaded = false;\\n\\n  /**\\n   * The page URL. It is used to compare against the current URL to check navigation state.\\n   *\\n   * @internal\\n   */\\n  protected url?: URL;\\n\\n  /**\\n   * Flag to know if the page has been persisted by the browser's back-forward cache.\\n   *\\n   * @internal\\n   */\\n  protected isPagePersisted = false;\\n\\n  /**\\n   * Computed to know which params we must get from URL. It gets the params names from the initial\\n   * state, to get all default params names, and also from the `$attrs` to get the extra params\\n   * names to take into account.\\n   *\\n   * @returns An array with the name of the params.\\n   *\\n   * @internal\\n   */\\n  protected get managedParamsNames(): string[] {\\n    return Object.keys({ ...initialUrlState, ...this.$attrs });\\n  }\\n\\n  /**\\n   * Returns the mapping of the param keys used in the URL is configured through $attrs. This way\\n   * we can support any param and extra param, no matters its name.\\n   *\\n   * @param paramName - The param name to get the Url key.\\n   * @returns The key used in the URL for the `paramName` passed.\\n   *\\n   * @internal\\n   */\\n  protected getUrlKey(paramName: string): string {\\n    return this.$attrs[paramName] ?? paramName;\\n  }\\n\\n  /**\\n   * To emit the Url events just when the URL is load, and before the components mounted events\\n   * and state changes, we do it in the created of this component.\\n   */\\n  created(): void {\\n    this.emitEvents();\\n  }\\n\\n  /**\\n   * Updates the browser URL with the new {@link UrlParams} using the history `pushState` method.\\n   *\\n   * @param newUrlParams - The new params to update browser URL.\\n   */\\n  @XOn('PushableUrlStateChanged')\\n  updateUrlWithPush(newUrlParams: UrlParams): void {\\n    this.updateUrl(newUrlParams, window.history.pushState.bind(window.history));\\n  }\\n\\n  /**\\n   * Updates the browser URL with the new {@link UrlParams} using the history `replaceState`\\n   * method.\\n   *\\n   * @param newUrlParams - The new params to update browser URL.\\n   */\\n  @XOn('ReplaceableUrlStateChanged')\\n  updateUrlWithReplace(newUrlParams: UrlParams): void {\\n    this.updateUrl(newUrlParams, window.history.replaceState.bind(window.history));\\n  }\\n\\n  /**\\n   * Handler of the\\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/pageshow_event | pageshow }\\n   * event.\\n   *\\n   * @remarks The pageshow event is listened to check if the browser has performed a navigation\\n   * using the back-forward cache. This information is available in the\\n   * PageTransitionEvent.persisted property.\\n   *\\n   * @param event - The page transition event.\\n   * @internal\\n   */\\n  protected onPageShow(event: PageTransitionEvent): void {\\n    this.isPagePersisted = event.persisted;\\n    if (event.persisted) {\\n      // The internal url is reset due to the back-forward cache storing the previous value which\\n      // is no longer valid.\\n      this.url = undefined;\\n    }\\n  }\\n\\n  /**\\n   * Emits the {@link UrlXEvents.ParamsLoadedFromUrl} XEvent,\\n   * the {@link UrlXEvents.ExtraParamsLoadedFromUrl} XEvent and, if there is query, also emits\\n   * the {@link XEventsTypes.UserOpenXProgrammatically}.\\n   *\\n   * @internal\\n   */\\n  protected emitEvents(): void {\\n    const { all, extra } = this.parseUrlParams();\\n    const metadata = this.createWireMetadata();\\n    this.$x.emit('ParamsLoadedFromUrl', all, metadata);\\n    this.$x.emit('ExtraParamsLoadedFromUrl', extra, metadata);\\n    // TODO: Move this logic from here.\\n    if (all.query) {\\n      this.$x.emit('UserOpenXProgrammatically', undefined, metadata);\\n    }\\n    this.urlLoaded = true;\\n  }\\n\\n  /**\\n   * Creates the wire metadata to include in every emitted {@link XEvent | XEvents}.\\n   *\\n   * @returns The {@link WireMetadata | metadata}.\\n   * @internal\\n   */\\n  protected createWireMetadata(): Pick<WireMetadata, 'feature' | 'location'> {\\n    return {\\n      feature: 'url',\\n      location: this.detectLocation()\\n    };\\n  }\\n\\n  /**\\n   * Detects the {@link FeatureLocation | location} used to build the\\n   * {@link QueryOriginInit | events metadata origin}.\\n   *\\n   * @returns The {@link FeatureLocation | location}.\\n   * @internal\\n   */\\n  protected detectLocation(): FeatureLocation {\\n    const currentUrl = new URL(window.location.href);\\n    const previousUrl = this.url;\\n    this.url = currentUrl;\\n\\n    const isInternalNavigation =\\n      previousUrl?.search !== currentUrl.search && previousUrl?.pathname === currentUrl.pathname;\\n    if (isInternalNavigation) {\\n      return 'url_history';\\n    }\\n\\n    if (this.isNavigatingFromPdp()) {\\n      return 'url_history_pdp';\\n    }\\n\\n    return 'external';\\n  }\\n\\n  /**\\n   * Check if the navigation is from a product page.\\n   *\\n   * @remarks Due to Safari 14 not supporting the new and standard PerformanceNavigationTiming\\n   * API, we are falling back to the deprecated one, PerformanceNavigation. We also fallback to\\n   * this API whenever we get a navigationType equal to reload, because Safari has a bug that the\\n   * navigationType is permanently set to reload after you have reload the page and it never\\n   * resets. As some browsers have a back-forward cache implemented, we also take into account if\\n   * the page is persisted.\\n   *\\n   * @returns True if the navigation is from a product page, false otherwise.\\n   * @internal\\n   */\\n  protected isNavigatingFromPdp(): boolean {\\n    const isPagePersisted = this.isPagePersisted;\\n    const navigationEntries = window.performance.getEntriesByType('navigation');\\n    const navigationType = (navigationEntries[0] as PerformanceNavigationTiming)?.type;\\n    const useFallbackStrategy =\\n      window.performance.navigation &&\\n      (isArrayEmpty(navigationEntries) || navigationType === 'reload');\\n\\n    // Reset internal isPagePersisted property value\\n    this.isPagePersisted = false;\\n\\n    if (useFallbackStrategy) {\\n      const {\\n        type: fallbackNavigationType,\\n        TYPE_BACK_FORWARD,\\n        TYPE_NAVIGATE\\n      } = window.performance.navigation;\\n      const isNavigatingInSpa =\\n        !!this.snippetConfig?.isSpa && fallbackNavigationType === TYPE_NAVIGATE;\\n      return fallbackNavigationType === TYPE_BACK_FORWARD || isNavigatingInSpa || isPagePersisted;\\n    } else {\\n      const isNavigatingInSpa = !!this.snippetConfig?.isSpa && navigationType === 'navigate';\\n      return navigationType === 'back_forward' || isNavigatingInSpa || isPagePersisted;\\n    }\\n  }\\n\\n  /**\\n   * Gets the {@link UrlParams} from the URL, including only the params defined by `paramsNames`.\\n   *\\n   * @returns ParsedUrlParams obtained from URL.\\n   * @internal\\n   */\\n  protected parseUrlParams(): ParsedUrlParams {\\n    const urlSearchParams = new URL(window.location.href).searchParams;\\n    return this.managedParamsNames.reduce<ParsedUrlParams>(\\n      (params, name) => {\\n        const urlKey = this.getUrlKey(name);\\n        if (urlSearchParams.has(urlKey)) {\\n          if (name in initialUrlState) {\\n            const urlValue = urlSearchParams.getAll(urlKey);\\n            params.all[name] = this.parseUrlParam(name, urlValue);\\n          } else {\\n            params.all[name] = params.extra[name] = urlSearchParams.get(urlKey);\\n          }\\n        }\\n        return params;\\n      },\\n      { all: { ...initialUrlState }, extra: {} }\\n    );\\n  }\\n\\n  /**\\n   * Updates the browser URL with the passed `newUrlParams` and using the browser history method\\n   * passed as `historyMethod`. It only updates the browser history if the new URL is different\\n   * from the current.\\n   *\\n   * @param newUrlParams - The new params to add to the browser URL.\\n   * @param historyMethod - The browser history method used to add the new URL.\\n   *\\n   * @internal\\n   */\\n  protected updateUrl(\\n    newUrlParams: UrlParams,\\n    historyMethod: History['pushState'] | History['replaceState']\\n  ): void {\\n    if (this.urlLoaded) {\\n      const url = new URL(window.location.href);\\n      this.deleteUrlParameters(url);\\n      this.setUrlParameters(url, newUrlParams);\\n      if (url.href.replace(/\\\\+/g, '%20') !== window.location.href) {\\n        historyMethod({ ...window.history.state }, document.title, url.href);\\n      }\\n      this.url = url;\\n    }\\n  }\\n\\n  /**\\n   * Deletes all the parameters in the passed URL.\\n   *\\n   * @param url - The URL to remove parameters from.\\n   * @internal\\n   * **/\\n  protected deleteUrlParameters(url: URL): void {\\n    this.managedParamsNames.forEach(paramName =>\\n      url.searchParams.delete(this.getUrlKey(paramName))\\n    );\\n  }\\n\\n  /**\\n   * Set all the provided parameters to the url with the mapped key.\\n   *\\n   * @param url - The current URL.\\n   * @param urlParams - The list of parameters to add.\\n   * @remarks The params are filtered because there maybe received extra params which will not be\\n   * managed by URL. This is defined by the `managedParamsNames` computed. Also, the parameters\\n   * are sorted Alphabetically to produce always the same URL with the same parameters.This is\\n   * important for SEO purposes.\\n   *\\n   * @internal\\n   * **/\\n  protected setUrlParameters(url: URL, urlParams: UrlParams): void {\\n    const filteredParams = objectFilter(urlParams, paramName =>\\n      this.managedParamsNames.includes(paramName as string)\\n    );\\n    const sortedParameters = this.sortParams(filteredParams);\\n    sortedParameters.forEach(([paramName, paramValue]) => {\\n      const urlParamKey = this.getUrlKey(paramName);\\n      if (Array.isArray(paramValue)) {\\n        paramValue.forEach(value => {\\n          url.searchParams.append(urlParamKey, String(value));\\n        });\\n      } else {\\n        url.searchParams.set(urlParamKey, String(paramValue));\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Sorts the params in a tuple array [key,value] to generate always the same URL with the params\\n   * in the same order.\\n   *\\n   * @param urlParams - The {@link UrlParams} to sort.\\n   * @returns An array of tuples with the key-value of each paramter, sorted by key.\\n   * @internal\\n   */\\n  protected sortParams(urlParams: UrlParams): Array<[string, unknown]> {\\n    return Object.entries(urlParams).sort(([param1], [param2]) => {\\n      return param1 < param2 ? -1 : 1;\\n    });\\n  }\\n\\n  /**\\n   * Returns the URL param value parsed depending on its type in the initial store state. As we\\n   * can not know what type can have an extra param, all extra params are parsed as strings. We\\n   * know if it is an extra param because it is not in the initial state.\\n   *\\n   * @param name - The name of the param in {@link UrlParams}.\\n   * @param value - The `URLSearchParams` value as an arry of strings.\\n   * @returns The parsed value.\\n   *\\n   * @internal\\n   */\\n  protected parseUrlParam(name: string, value: string[]): UrlParamValue {\\n    switch (typeof initialUrlState[name]) {\\n      case 'number':\\n        return Number(value[0]);\\n      case 'boolean':\\n        return value[0].toLowerCase() === 'true';\\n      case 'string':\\n        return value[0];\\n      default:\\n        // array\\n        return value;\\n    }\\n  }\\n}\\n\"],\"names\":[],\"mappings\":\"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\"}")}}]);