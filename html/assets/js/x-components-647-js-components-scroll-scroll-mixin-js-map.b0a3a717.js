(window.webpackJsonp=window.webpackJsonp||[]).push([[922],{1200:function(A,n){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"scroll.mixin.js\",\"sources\":[\"../../../../src/components/scroll/scroll.mixin.ts\"],\"sourcesContent\":[\"import Vue from 'vue';\\nimport { Component, Prop, Watch } from 'vue-property-decorator';\\nimport { throttle } from '../../utils/throttle';\\nimport { XEvent } from '../../wiring/events.types';\\nimport { XOn } from '../decorators/bus.decorators';\\nimport { ScrollDirection } from './scroll.types';\\n\\n/**\\n * Mixin to share Scroll logic.\\n *\\n * @public\\n */\\n@Component\\n/* eslint-disable @typescript-eslint/unbound-method */\\nexport default class ScrollMixin extends Vue {\\n  /**\\n   * The scrolling container reference.\\n   *\\n   * @public\\n   */\\n  public $el!: HTMLElement;\\n  /**\\n   * Distance to the end of the scroll that when reached will emit the\\n   * `scroll:about-to-end` event.\\n   *\\n   * @public\\n   */\\n  @Prop({ default: 100 })\\n  public distanceToBottom!: number;\\n  /**\\n   * Positive vertical distance to still consider that the an element is the first one visible.\\n   * For example, if set to 100, after scrolling 100 pixels, the first rendered element\\n   * will still be considered the first one.\\n   */\\n  @Prop({ default: 100 })\\n  public firstElementThresholdPx!: number;\\n  /**\\n   * Time duration to ignore the subsequent scroll events after an emission.\\n   * Higher values will decrease events precision but can prevent performance issues.\\n   *\\n   * @public\\n   */\\n  @Prop({ default: 100 })\\n  public throttleMs!: number;\\n\\n  /**\\n   * If true (default), sets the scroll position to the top when certain events are emitted.\\n   *\\n   * @public\\n   */\\n  @Prop({ type: Boolean, default: true })\\n  protected resetOnChange!: boolean;\\n\\n  /**\\n   * List of events that should reset the scroll when emitted.\\n   *\\n   * @public\\n   */\\n  @Prop({\\n    default: () => [\\n      'SearchBoxQueryChanged',\\n      'SortChanged',\\n      'SelectedFiltersChanged',\\n      'SelectedRelatedTagsChanged',\\n      'UserChangedExtraParams'\\n    ]\\n  })\\n  public resetOn!: XEvent;\\n\\n  /**\\n   * Property for getting the client height of scroll.\\n   *\\n   * @internal\\n   */\\n  protected clientHeight = 0;\\n  /**\\n   * Property for getting the current position of scroll.\\n   *\\n   * @internal\\n   */\\n  protected currentPosition = 0;\\n  /**\\n   * Property for getting the direction of scroll.\\n   *\\n   * @internal\\n   */\\n  protected direction!: ScrollDirection;\\n  /**\\n   * Property for getting the previous position of scroll.\\n   *\\n   * @internal\\n   */\\n  protected previousPosition = 0;\\n  /**\\n   * Property for getting the scroll height.\\n   *\\n   * @internal\\n   */\\n  protected scrollHeight = 0;\\n\\n  /**\\n   * Throttled version of the function that stores the DOM scroll related properties.\\n   * The duration of the throttle is configured through the\\n   * {@link ScrollMixin.throttleMs}.\\n   *\\n   * @returns A throttled version of the function to store the scroll data.\\n   * @internal\\n   */\\n  protected get throttledStoreScrollData(): () => void {\\n    return throttle(this.storeScrollData, this.throttleMs);\\n  }\\n\\n  /**\\n   * Returns distance missing to end position position.\\n   *\\n   * @returns A number for knowing the distance missing to end position position.\\n   * @internal\\n   */\\n  protected get distanceToEnd(): number {\\n    return this.scrollEndPosition - this.currentPosition;\\n  }\\n\\n  /**\\n   * Returns `true` when the amount of pixels scrolled is greater than\\n   * the {@link ScrollMixin.distanceToBottom}.\\n   *\\n   * @returns A boolean for knowing if the user is about to reaching to the end.\\n   * @internal\\n   */\\n  protected get hasScrollAlmostReachedEnd(): boolean {\\n    return !this.hasScrollReachedStart && this.distanceToBottom > this.distanceToEnd;\\n  }\\n\\n  /**\\n   * Returns `true` when there is no more content to scroll.\\n   *\\n   * @returns A boolean for knowing if the user scrolls to the end.\\n   * @internal\\n   */\\n  protected get hasScrollReachedEnd(): boolean {\\n    return this.currentPosition === this.scrollEndPosition;\\n  }\\n\\n  /**\\n   * Returns `true` when the scroll is at the initial position.\\n   *\\n   * @returns A boolean for knowing if the user scrolls to the start.\\n   * @internal\\n   */\\n  protected get hasScrollReachedStart(): boolean {\\n    return this.currentPosition === 0;\\n  }\\n\\n  /**\\n   * Returns direction of scroll based in {@link ScrollDirection}.\\n   *\\n   * @returns The scroll direction.\\n   * @internal\\n   */\\n  protected get scrollDirection(): ScrollDirection {\\n    return this.currentPosition > this.previousPosition ? 'DOWN' : 'UP';\\n  }\\n\\n  /**\\n   * Returns end position of scroll.\\n   *\\n   * @returns A number for knowing end position of scroll.\\n   * @internal\\n   */\\n  protected get scrollEndPosition(): number {\\n    return this.scrollHeight - this.clientHeight;\\n  }\\n\\n  /**\\n   * Initialises DOM dependant scroll properties.\\n   *\\n   * @internal\\n   */\\n  mounted(): void {\\n    this.$nextTick().then(() => {\\n      if (!this.$el) {\\n        // TODO Replace with Empathy's logger\\n        // eslint-disable-next-line no-console\\n        console.warn(\\n          '[ScrollMixin]',\\n          'Components using this mixin must set `this.$el` to the HTML node that is scrolling.'\\n        );\\n      } else {\\n        this.storeScrollData();\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Resets the scroll position.\\n   *\\n   * @internal\\n   */\\n  @XOn(instance => (instance as ScrollMixin).resetOn)\\n  resetScroll(): void {\\n    this.$nextTick().then(() => {\\n      if (this.resetOnChange) {\\n        this.$el.scrollTo({ top: 0 });\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Emits the `scroll` event.\\n   *\\n   * @param _newScrollPosition - The new position of scroll.\\n   * @param oldScrollPosition - The old position of scroll.\\n   * @internal\\n   */\\n  @Watch('currentPosition')\\n  protected emitScroll(_newScrollPosition: number, oldScrollPosition: number): void {\\n    this.$emit('scroll', this.currentPosition);\\n    this.previousPosition = oldScrollPosition;\\n  }\\n\\n  /**\\n   * Emits the 'scroll:at-start' event when the user reaches the start.\\n   *\\n   * @param isScrollAtStart - For knowing if the user reaches at start.\\n   * @internal\\n   */\\n  @Watch('hasScrollReachedStart')\\n  protected emitScrollReachedAtStart(isScrollAtStart: boolean): void {\\n    this.$emit('scroll:at-start', isScrollAtStart);\\n  }\\n\\n  /**\\n   * Emits the 'scroll:almost-at-end' event when the user is about to reach to end.\\n   *\\n   * @param isScrollAlmostAtEnd - For knowing if the user is about to reach to end.\\n   * @internal\\n   */\\n  @Watch('hasScrollAlmostReachedEnd')\\n  protected emitScrollAlmostAtEnd(isScrollAlmostAtEnd: boolean): void {\\n    this.$emit('scroll:almost-at-end', isScrollAlmostAtEnd);\\n  }\\n\\n  /**\\n   * Emits the 'scroll:at-end' event when the user reaches the end.\\n   *\\n   * @param isScrollAtEnd - For knowing if the user reaches at end.\\n   * @internal\\n   */\\n  @Watch('hasScrollReachedEnd')\\n  protected emitScrollAtEnd(isScrollAtEnd: boolean): void {\\n    this.$emit('scroll:at-end', isScrollAtEnd);\\n  }\\n\\n  /**\\n   * Emits the `scroll:direction-change` event when the scrolling direction has changed.\\n   *\\n   * @param direction - The new direction of scroll.\\n   * @internal\\n   */\\n  @Watch('scrollDirection')\\n  protected emitScrollDirection(direction: ScrollDirection): void {\\n    this.$emit('scroll:direction-change', direction);\\n  }\\n\\n  /**\\n   * Updates scroll related properties.\\n   *\\n   * @internal\\n   */\\n  protected storeScrollData(): void {\\n    if (this.$el) {\\n      this.currentPosition = this.$el.scrollTop;\\n      this.scrollHeight = this.$el.scrollHeight;\\n      this.clientHeight = this.$el.clientHeight;\\n    }\\n  }\\n}\\n/*  eslint-enable @typescript-eslint/unbound-method */\\n\"],\"names\":[],\"mappings\":\"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\"}")}}]);