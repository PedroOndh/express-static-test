(window.webpackJsonp=window.webpackJsonp||[]).push([[657],{1433:function(n,e){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"main-scroll.vue.js\",\"sources\":[\"../../../../../src/x-modules/scroll/components/main-scroll.vue\"],\"sourcesContent\":[\"<template>\\n  <NoElement :class=\\\"dynamicClasses\\\">\\n    <slot />\\n  </NoElement>\\n</template>\\n<script lang=\\\"ts\\\">\\n  import Vue from 'vue';\\n  import { Component, Prop, Watch } from 'vue-property-decorator';\\n  import { XEmit } from '../../../components/decorators/bus.decorators';\\n  import { XProvide } from '../../../components/decorators/injection.decorators';\\n  import { State } from '../../../components/decorators/store.decorators';\\n  import { NoElement } from '../../../components/no-element';\\n  import { xComponentMixin } from '../../../components/x-component.mixin';\\n  import { VueCSSClasses } from '../../../utils/index';\\n  import { scrollXModule } from '../x-module';\\n  import { ScrollObserverKey } from './scroll.const';\\n  import { ScrollVisibilityObserver } from './scroll.types';\\n\\n  /**\\n   * Extends the scroll making it able to sync the first visible element, and allowing\\n   * the children position to be restored.\\n   *\\n   * Each child element that wants to have this support must be wrapped in a {@link MainScrollItem}\\n   * component.\\n   *\\n   * @public\\n   */\\n  @Component({\\n    components: { NoElement },\\n    mixins: [xComponentMixin(scrollXModule)]\\n  })\\n  /* eslint-disable @typescript-eslint/unbound-method */\\n  export default class MainScroll extends Vue {\\n    /**\\n     * If `true`, sets this scroll instance to the main of the application. Being the main\\n     * scroll implies that features like restoring the scroll when the query changes, or storing\\n     * the scroll position in the URL will be enabled for this container.\\n     *\\n     * @public\\n     */\\n    @Prop({ default: false, type: Boolean })\\n    public useWindow!: boolean;\\n\\n    /**\\n     * Timeout in milliseconds to abort trying to restore the scroll position to the target\\n     * element.\\n     *\\n     * @public\\n     */\\n    @Prop({ default: 5000 })\\n    public restoreScrollTimeoutMs!: number;\\n\\n    /**\\n     * Intersection percentage to consider an element visible.\\n     *\\n     * @public\\n     */\\n    @Prop({ default: 0.3 })\\n    public threshold!: number;\\n\\n    /**\\n     * Adjusts the size of the scroll container bounds.\\n     *\\n     * @public\\n     */\\n    @Prop({ default: '0px' })\\n    public margin!: string;\\n\\n    /**\\n     * The elements that are currently considered visible.\\n     *\\n     * @internal\\n     */\\n    protected intersectingElements: HTMLElement[] = [];\\n\\n    /**\\n     * Intersection observer to determine visibility of the elements.\\n     *\\n     * @returns An intersection observer to detect elements visibility.\\n     * @internal\\n     */\\n    protected intersectionObserver: IntersectionObserver | null = null;\\n\\n    /**\\n     * Stores the identifier of the timeout that will consider the scroll failed to restore.\\n     *\\n     * @internal\\n     */\\n    protected restoreScrollFailTimeoutId?: number;\\n\\n    /**\\n     * Pending identifier scroll position to restore. If it matches the {@link MainScrollItem.item}\\n     * `id` property, this component should be scrolled into view.\\n     *\\n     * @internal\\n     */\\n    @State('scroll', 'pendingScrollTo')\\n    public pendingScrollTo!: string;\\n\\n    /**\\n     * Creates an `IntersectionObserver` to detect the first visible elements. Children of this\\n     * component should register themselves if they want to be observed.\\n     *\\n     * @returns The intersection observer.\\n     * @public\\n     */\\n    @XProvide(ScrollObserverKey)\\n    public get visibleElementsObserver(): ScrollVisibilityObserver | null {\\n      const observer = this.intersectionObserver;\\n      return observer\\n        ? {\\n            observe: observer.observe.bind(observer),\\n            unobserve: element => {\\n              this.removeVisibleElement(element);\\n              observer.unobserve(element);\\n            }\\n          }\\n        : null;\\n    }\\n\\n    /**\\n     * The first visible element contained in this component.\\n     *\\n     * @returns The first visible element in this component.\\n     * @internal\\n     */\\n    @XEmit('UserScrolledToElement')\\n    public get firstVisibleElement(): string | '' {\\n      if (this.intersectingElements.length === 0) {\\n        return '';\\n      }\\n      const firstVisibleElement = this.intersectingElements.reduce(\\n        (firstVisibleElement, anotherElement) => {\\n          // FIXME: This algorithm only takes into account LTR layouts\\n          const firstVisibleElementBounds = firstVisibleElement.getBoundingClientRect();\\n          const anotherElementBounds = anotherElement.getBoundingClientRect();\\n          return anotherElementBounds.left <= firstVisibleElementBounds.left &&\\n            anotherElementBounds.top <= firstVisibleElementBounds.top\\n            ? anotherElement\\n            : firstVisibleElement;\\n        }\\n      );\\n\\n      return firstVisibleElement === this.$el.querySelector('[data-scroll]')\\n        ? ''\\n        : firstVisibleElement.dataset.scroll!;\\n    }\\n\\n    /**\\n     * Initialise the observer after mounting the component.\\n     */\\n    mounted(): void {\\n      this.intersectionObserver = new IntersectionObserver(this.updateVisibleElements, {\\n        root: this.useWindow ? document : this.$el,\\n        threshold: this.threshold,\\n        rootMargin: this.margin\\n      });\\n    }\\n\\n    /**\\n     * Disconnects the intersection observer.\\n     *\\n     * @internal\\n     */\\n    beforeDestroy(): void {\\n      this.intersectionObserver?.disconnect();\\n      this.$x.emit('UserScrolledToElement', '');\\n    }\\n\\n    /**\\n     * Disconnects the previous observer.\\n     *\\n     * @param _new - The new `IntersectionObserver`.\\n     * @param old - The new `IntersectionObserver`.\\n     * @internal\\n     */\\n    @Watch('intersectionObserver')\\n    protected disconnectPreviousObserver(\\n      _new: IntersectionObserver | null,\\n      old: IntersectionObserver | null\\n    ): void {\\n      old?.disconnect();\\n    }\\n\\n    /**\\n     * If there is a pending scroll, starts a countdown to stop trying to restore the scroll.\\n     *\\n     * @param pendingScrollTo - The position the scroll should be restored to.\\n     * @internal\\n     */\\n    @Watch('pendingScrollTo')\\n    protected failRestoringScroll(pendingScrollTo: string | null): void {\\n      // TODO Move this logic to the wiring. A cancelable delay operator is needed\\n      clearTimeout(this.restoreScrollFailTimeoutId);\\n      if (pendingScrollTo) {\\n        this.restoreScrollFailTimeoutId = setTimeout(() => {\\n          this.$x.emit('ScrollRestoreFailed');\\n        }, this.restoreScrollTimeoutMs);\\n      }\\n    }\\n\\n    /**\\n     * Removes an element from the {@link MainScroll.intersectingElements} list.\\n     *\\n     * @param element - The element to remove from the visible elements.\\n     * @internal\\n     */\\n    protected removeVisibleElement(element: HTMLElement): void {\\n      const index = this.intersectingElements.indexOf(element);\\n      if (index !== -1) {\\n        this.intersectingElements.splice(index, 1);\\n      }\\n    }\\n\\n    /**\\n     * Updates the visible elements given a list of intersection observer entries.\\n     *\\n     * @param entries - The entries from whom update the visibility.\\n     * @internal\\n     */\\n    protected updateVisibleElements(entries: IntersectionObserverEntry[]): void {\\n      entries.forEach(entry => {\\n        const target = entry.target as HTMLElement;\\n        if (entry.isIntersecting) {\\n          this.intersectingElements.push(target);\\n        } else {\\n          this.removeVisibleElement(target);\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Adds the dynamic css classes to the component.\\n     *\\n     * @returns The class to be added to the component.\\n     *\\n     * @internal\\n     */\\n    protected get dynamicClasses(): VueCSSClasses {\\n      return {\\n        'x-main-scroll--no-transition': !!this.pendingScrollTo\\n      };\\n    }\\n  }\\n<\/script>\\n<style lang=\\\"scss\\\">\\n  .x-main-scroll--no-transition {\\n    * {\\n      transition: none !important;\\n      transform: none !important;\\n      opacity: 1 !important;\\n    }\\n  }\\n</style>\\n\\n<docs lang=\\\"mdx\\\">\\n## Events\\n\\nThis component emits the following events:\\n\\n[`UserScrolledToElement`](./../../api/x-components.scrollxevents.md)\\n[`ScrollRestoreFailed`](./../../api/x-components.scrollxevents.md)\\n\\n## See it in action\\n\\nThe `MainScroll` component must be an ancestor of the `MainScrollItem` components. This is because\\nit injects the needed utilities to determine the first visible item.\\n\\n```vue\\n<template>\\n  <MainScroll>\\n    <ul>\\n      <MainScrollItem v-for=\\\"item in 24\\\" tag=\\\"li\\\">Item {{ item }}</MainScrollItem>\\n    </ul>\\n  </MainScroll>\\n</template>\\n\\n<script>\\n  import { MainScroll, MainScrollItem } from '@empathyco/x-components/scroll';\\n\\n  export default {\\n    name: 'MainScrollDemo',\\n    components: {\\n      MainScroll,\\n      MainScrollItem\\n    }\\n  };\\n<\/script>\\n\\n<style scoped>\\n  ul {\\n    overflow: auto;\\n    max-height: 200px;\\n  }\\n\\n  li {\\n    height: 50px;\\n    line-height: 50px;\\n  }\\n</style>\\n```\\n\\n### Play with props\\n\\n#### Window scroll\\n\\nIn case you aren't using a custom scrolling element like the `Scroll` panel, and want to use the\\ndefault browser scroll, you can do so by using the `useWindow` prop:\\n\\n```vue\\n<template>\\n  <MainScroll useWindow>\\n    <ul>\\n      <MainScrollItem v-for=\\\"item in 24\\\" tag=\\\"li\\\">Item {{ item }}</MainScrollItem>\\n    </ul>\\n  </MainScroll>\\n</template>\\n\\n<script>\\n  import { MainScroll, MainScrollItem } from '@empathyco/x-components/scroll';\\n\\n  export default {\\n    name: 'MainScrollDemo',\\n    components: {\\n      MainScroll,\\n      MainScrollItem\\n    }\\n  };\\n<\/script>\\n```\\n\\n#### Timeout for restoring scroll\\n\\nWhen your application is loaded, this component, together with the `MainScrollItem` will try to\\nrestore the scroll to the provided position (if available). Because of the dynamic nature of\\nJavaScript applications, the element that it tries to restore the scroll to might not be available\\nanymore. For this reason after a defined time, the scroll restoration will be considered failed.\\n\\nThis time can be configured through the `restore-scroll-timeout-ms` prop. This is specially useful\\nwhen combined with the URL X Module.\\n\\n```vue\\n<template>\\n  <MainScroll :restoreScrollTimeoutMs=\\\"1000\\\">\\n    <ul>\\n      <MainScrollItem v-for=\\\"item in 24\\\" tag=\\\"li\\\">Item {{ item }}</MainScrollItem>\\n    </ul>\\n  </MainScroll>\\n</template>\\n\\n<script>\\n  import { MainScroll, MainScrollItem } from '@empathyco/x-components/scroll';\\n\\n  export default {\\n    name: 'MainScrollDemo',\\n    components: {\\n      MainScroll,\\n      MainScrollItem\\n    }\\n  };\\n<\/script>\\n```\\n\\n#### Adjust first visible item\\n\\nBy default this component will consider the first visible item, the first element that is at least\\nintersecting a 50% with its container. However this arbitrary number might not always be the best.\\n\\nTo configure this, you can use the `margin` and `threshold` props, which work exactly like in the\\n`IntersectionObserver` API. In this example we are reducing the bounds of the intersection by 50px,\\nand adjusting the element to be at least 75% intersecting.\\n\\n```vue\\n<template>\\n  <MainScroll :threshold=\\\"0.75\\\" margin=\\\"-50px\\\">\\n    <ul>\\n      <MainScrollItem v-for=\\\"item in 24\\\" tag=\\\"li\\\">Item {{ item }}</MainScrollItem>\\n    </ul>\\n  </MainScroll>\\n</template>\\n\\n<script>\\n  import { MainScroll, MainScrollItem } from '@empathyco/x-components/scroll';\\n\\n  export default {\\n    name: 'MainScrollDemo',\\n    components: {\\n      MainScroll,\\n      MainScrollItem\\n    }\\n  };\\n<\/script>\\n```\\n</docs>\\n\"],\"names\":[\"const\"],\"mappings\":\";;;;;AAEAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\"}")}}]);