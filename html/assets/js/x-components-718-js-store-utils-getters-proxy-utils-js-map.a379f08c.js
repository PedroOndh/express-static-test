(window.webpackJsonp=window.webpackJsonp||[]).push([[948],{1223:function(e,A){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"getters-proxy.utils.js\",\"sources\":[\"../../../../src/store/utils/getters-proxy.utils.ts\"],\"sourcesContent\":[\"import { Store } from 'vuex';\\nimport { reduce } from '../../utils/object';\\nimport { Dictionary } from '../../utils/types';\\nimport { ExtractGetters, XModuleName } from '../../x-modules/x-modules.types';\\nimport { AnyXStoreModule } from '../store.types';\\n\\ntype Getters = { [ModuleName in XModuleName]?: ExtractGetters<ModuleName> };\\nlet cache: Getters = {};\\n/**\\n * Creates or return a proxy object of the getters of the storeModule passed.\\n *\\n * @param getters - The Vuex Store Getters.\\n * @param moduleName - The name of the module.\\n * @param storeModule - The store module.\\n * @returns A {@link GettersTree} object with only the getters of the {@link XModule}.\\n *\\n * @internal\\n *\\n * @remarks This proxy will be used by the stateSelector, of the module. This is done to ensure that\\n * a Vuex stateSelector can only access the getters of the {@link XModule} where it is registered.\\n * This function task can be done with {@link getGettersProxy}, just without passing the\\n * storeModule. But in that case every time we register emitters in a module, it will loop over all\\n * the getters of all the store. This way, passing the moduleNeeded, it only loops over the getters\\n * of that module. It is a performance question to have this two different implementations.\\n *\\n */\\nexport function getGettersProxyFromModule<ModuleName extends XModuleName>(\\n  getters: Pick<Store<any>, 'getters'>,\\n  moduleName: ModuleName,\\n  storeModule: AnyXStoreModule\\n): ExtractGetters<ModuleName> {\\n  /* TODO: Review why TS is not able to exclude undefined types from the Getters cache */\\n  const cachedGetter = cache[moduleName];\\n  if (isCacheGetterDefined<ModuleName>(cachedGetter)) {\\n    return cachedGetter;\\n  }\\n  const modulePath = `x/${moduleName}/`;\\n  const safeGetters = reduce(\\n    storeModule.getters as Dictionary,\\n    (safeGettersProxy, getterName) =>\\n      defineGetterProxy(safeGettersProxy, getterName, `${modulePath}${getterName}`, getters),\\n    {} as ExtractGetters<ModuleName>\\n  );\\n  cache[moduleName] = safeGetters as unknown as Getters[ModuleName];\\n  return safeGetters;\\n}\\n\\n/**\\n * Creates or return a proxy object of the getters of the module with the moduleName passed.\\n *\\n * @param getters - The Vuex Store Getters.\\n * @param moduleName - The name of the module.\\n * @returns A {@link GettersTree} object with only the getters of the {@link XModule}.\\n *\\n * @internal\\n *\\n * @remarks This proxy will be used wireCommit to pass the module state and getters, to a function\\n * that will return the payload to commit the mutation.\\n */\\nexport function getGettersProxy<ModuleName extends XModuleName>(\\n  getters: Pick<Store<any>, 'getters'>,\\n  moduleName: ModuleName\\n): ExtractGetters<ModuleName> {\\n  /* TODO: Review why TS is not able to exclude undefined types from the Getters cache */\\n  const cachedGetter = cache[moduleName];\\n  if (isCacheGetterDefined<ModuleName>(cachedGetter)) {\\n    return cachedGetter;\\n  }\\n  const modulePath = `x/${moduleName}/`;\\n  const getterKeys: string[] = Object.keys(getters).filter(getterKey =>\\n    getterKey.startsWith(modulePath)\\n  );\\n  const safeGetters = getterKeys.reduce((safeGettersProxy, fullPathGetterName) => {\\n    const getterName = fullPathGetterName.replace(modulePath, '');\\n    return defineGetterProxy(safeGettersProxy, getterName, fullPathGetterName, getters);\\n  }, {} as ExtractGetters<ModuleName>);\\n  cache[moduleName] = safeGetters as unknown as Getters[ModuleName];\\n  return safeGetters;\\n}\\n\\n/**\\n * Defines a JS getter in safeGettersProxy object that returns the Vuex getter value.\\n *\\n * @param safeGettersProxy - The object where the proxy will be defined.\\n * @param getterName - The name of the Getter without path. For example: 'trimQuery'.\\n * @param fullPathGetterName - The name of the getter to be accessed with the full path.\\n * For example: 'x/searchBox/trimmedQuery'.\\n * @param getters - The Vuex Store Getters.\\n * @returns The same safeGetterProxy with new get defined.\\n *\\n * @internal\\n */\\nfunction defineGetterProxy<ModuleName extends XModuleName>(\\n  safeGettersProxy: ExtractGetters<ModuleName>,\\n  getterName: string,\\n  fullPathGetterName: string,\\n  getters: Dictionary\\n): ExtractGetters<ModuleName> {\\n  return Object.defineProperty(safeGettersProxy, getterName, {\\n    get() {\\n      return getters[fullPathGetterName];\\n    },\\n    enumerable: true\\n  });\\n}\\n\\n/** Clean the cache (This is for testing purpose).\\n *\\n * @internal\\n * */\\nexport function cleanGettersProxyCache(): void {\\n  cache = {};\\n}\\n\\n/**\\n * Checks if the getter cached is defined.\\n *\\n * @param cachedGetter - The getter cached.\\n * @returns If the getters is defined or not.\\n *\\n * @internal\\n */\\nfunction isCacheGetterDefined<ModuleName extends XModuleName>(\\n  cachedGetter: ExtractGetters<ModuleName> | undefined | unknown\\n): cachedGetter is ExtractGetters<ModuleName> {\\n  return cachedGetter !== undefined;\\n}\\n\"],\"names\":[],\"mappings\":\";;AAOA,IAAI,KAAK,GAAY,EAAE,CAAC;AACxB;;;;;;;;;;;;;;;;;;SAkBgB,yBAAyB,CACvC,OAAoC,EACpC,UAAsB,EACtB,WAA4B;;IAG5B,IAAM,YAAY,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC;IACvC,IAAI,oBAAoB,CAAa,YAAY,CAAC,EAAE;QAClD,OAAO,YAAY,CAAC;KACrB;IACD,IAAM,UAAU,GAAG,OAAK,UAAU,MAAG,CAAC;IACtC,IAAM,WAAW,GAAG,MAAM,CACxB,WAAW,CAAC,OAAqB,EACjC,UAAC,gBAAgB,EAAE,UAAU;QAC3B,OAAA,iBAAiB,CAAC,gBAAgB,EAAE,UAAU,EAAE,KAAG,UAAU,GAAG,UAAY,EAAE,OAAO,CAAC;KAAA,EACxF,EAAgC,CACjC,CAAC;IACF,KAAK,CAAC,UAAU,CAAC,GAAG,WAA6C,CAAC;IAClE,OAAO,WAAW,CAAC;AACrB,CAAC;AAED;;;;;;;;;;;;SAYgB,eAAe,CAC7B,OAAoC,EACpC,UAAsB;;IAGtB,IAAM,YAAY,GAAG,KAAK,CAAC,UAAU,CAAC,CAAC;IACvC,IAAI,oBAAoB,CAAa,YAAY,CAAC,EAAE;QAClD,OAAO,YAAY,CAAC;KACrB;IACD,IAAM,UAAU,GAAG,OAAK,UAAU,MAAG,CAAC;IACtC,IAAM,UAAU,GAAa,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,MAAM,CAAC,UAAA,SAAS;QAChE,OAAA,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC;KAAA,CACjC,CAAC;IACF,IAAM,WAAW,GAAG,UAAU,CAAC,MAAM,CAAC,UAAC,gBAAgB,EAAE,kBAAkB;QACzE,IAAM,UAAU,GAAG,kBAAkB,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;QAC9D,OAAO,iBAAiB,CAAC,gBAAgB,EAAE,UAAU,EAAE,kBAAkB,EAAE,OAAO,CAAC,CAAC;KACrF,EAAE,EAAgC,CAAC,CAAC;IACrC,KAAK,CAAC,UAAU,CAAC,GAAG,WAA6C,CAAC;IAClE,OAAO,WAAW,CAAC;AACrB,CAAC;AAED;;;;;;;;;;;;AAYA,SAAS,iBAAiB,CACxB,gBAA4C,EAC5C,UAAkB,EAClB,kBAA0B,EAC1B,OAAmB;IAEnB,OAAO,MAAM,CAAC,cAAc,CAAC,gBAAgB,EAAE,UAAU,EAAE;QACzD,GAAG;YACD,OAAO,OAAO,CAAC,kBAAkB,CAAC,CAAC;SACpC;QACD,UAAU,EAAE,IAAI;KACjB,CAAC,CAAC;AACL,CAAC;AAED;;;;SAIgB,sBAAsB;IACpC,KAAK,GAAG,EAAE,CAAC;AACb,CAAC;AAED;;;;;;;;AAQA,SAAS,oBAAoB,CAC3B,YAA8D;IAE9D,OAAO,YAAY,KAAK,SAAS,CAAC;AACpC;;;;\"}")}}]);