(window.webpackJsonp=window.webpackJsonp||[]).push([[973],{1246:function(e,A){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"wires-operators.utils.js\",\"sources\":[\"../../../src/wiring/wires-operators.utils.ts\"],\"sourcesContent\":[\"import { Subject, Observable, timer, race } from 'rxjs';\\nimport { takeUntil } from 'rxjs/operators';\\nimport { Store } from 'vuex';\\nimport { XBus } from '../plugins/x-bus.types';\\nimport { RootXStoreState } from '../store/store.types';\\nimport { MaybeArray } from '../utils/types';\\nimport { XEvent } from './events.types';\\nimport { TimedWireOperatorOptions, TimeSelector } from './wiring.types';\\n\\n/**\\n * Creates the observable for the events that will be racing the wire's execution.\\n *\\n * @param events - The events to merge its observables.\\n * @param on - The on function of the {@link XBus} where the events will run.\\n * @returns The observable for the racing events.\\n * @internal\\n */\\nexport function mergeEvents(events: MaybeArray<XEvent>, on: XBus['on']): Observable<void> {\\n  const subject = new Subject<void>();\\n  const eventsList = Array.isArray(events) ? events : [events];\\n\\n  /* Can't use RxJS `merge` function, as it immediately emits previously emitted values to new\\n   subscriptions due to the `ReplaySubject` of the bus. With this Subject we are still receiving\\n   those values immediately on subscription, but as there are no subscribers before the `return`\\n   happens we are fine. */\\n  eventsList.forEach(raceEvent => on(raceEvent).subscribe(() => subject.next()));\\n  return subject;\\n}\\n\\n/**\\n * Checks how to retrieve the timeout time, retrieves it and returns it in ms.\\n *\\n * @param timeInMs - Time for the timeout in ms.\\n * @param store - The store of the wire that will be timed out.\\n * @returns The time in ms for the timeout.\\n * @internal\\n */\\nexport function normalizeTime(\\n  timeInMs: TimeSelector | number,\\n  store: Store<RootXStoreState>\\n): number {\\n  return typeof timeInMs === 'function' ? timeInMs(store) : timeInMs;\\n}\\n\\n/**\\n * Creates a timer observable that depending on the provided options might be aborted or forced.\\n *\\n * @param durationInMs - The duration in ms for the timer.\\n * @param options - Options to configure the timer, like an events to force it or cancel it.\\n * @param on - The {@link XBus.on} method.\\n * @returns A timer observable that can be aborted or forced depending on the provided options.\\n * @internal\\n */\\nexport function createTimer(\\n  durationInMs: number,\\n  { cancelOn, forceOn }: TimedWireOperatorOptions,\\n  on: XBus['on']\\n): Observable<unknown> {\\n  let timerObservable: Observable<unknown> = timer(durationInMs);\\n  if (forceOn) {\\n    timerObservable = race(timerObservable, mergeEvents(forceOn, on));\\n  }\\n\\n  if (cancelOn) {\\n    timerObservable = timerObservable.pipe(takeUntil(mergeEvents(cancelOn, on)));\\n  }\\n\\n  return timerObservable;\\n}\\n\"],\"names\":[],\"mappings\":\";;;AASA;;;;;;;;SAQgB,WAAW,CAAC,MAA0B,EAAE,EAAc;IACpE,IAAM,OAAO,GAAG,IAAI,OAAO,EAAQ,CAAC;IACpC,IAAM,UAAU,GAAG,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,MAAM,GAAG,CAAC,MAAM,CAAC,CAAC;;;;;IAM7D,UAAU,CAAC,OAAO,CAAC,UAAA,SAAS,IAAI,OAAA,EAAE,CAAC,SAAS,CAAC,CAAC,SAAS,CAAC,cAAM,OAAA,OAAO,CAAC,IAAI,EAAE,GAAA,CAAC,GAAA,CAAC,CAAC;IAC/E,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;;;;;;SAQgB,aAAa,CAC3B,QAA+B,EAC/B,KAA6B;IAE7B,OAAO,OAAO,QAAQ,KAAK,UAAU,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC;AACrE,CAAC;AAED;;;;;;;;;SASgB,WAAW,CACzB,YAAoB,EACpB,EAA+C,EAC/C,EAAc;QADZ,QAAQ,cAAA,EAAE,OAAO,aAAA;IAGnB,IAAI,eAAe,GAAwB,KAAK,CAAC,YAAY,CAAC,CAAC;IAC/D,IAAI,OAAO,EAAE;QACX,eAAe,GAAG,IAAI,CAAC,eAAe,EAAE,WAAW,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;KACnE;IAED,IAAI,QAAQ,EAAE;QACZ,eAAe,GAAG,eAAe,CAAC,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;KAC9E;IAED,OAAO,eAAe,CAAC;AACzB;;;;\"}")}}]);