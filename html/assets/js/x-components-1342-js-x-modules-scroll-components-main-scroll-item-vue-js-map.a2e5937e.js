(window.webpackJsonp=window.webpackJsonp||[]).push([[655],{1431:function(e,n){throw new Error('Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {"version":3,"file":"main-scroll-item.vue.js","sources":["../../../../../src/x-modules/scroll/components/main-scroll-item.vue"],"sourcesContent":["<template>\\n  <component :is=\\"tag\\" :data-scroll=\\"item.id\\">\\n    <slot />\\n  </component>\\n</template>\\n<script lang=\\"ts\\">\\n  import { Identifiable } from \'@empathyco/x-types\';\\n  import Vue from \'vue\';\\n  import { Component, Prop } from \'vue-property-decorator\';\\n  import { NoElement, State, xComponentMixin } from \'../../../components\';\\n  import { XInject } from \'../../../components/decorators/injection.decorators\';\\n  import { scrollXModule } from \'../x-module\';\\n  import { ScrollObserverKey } from \'./scroll.const\';\\n  import { ScrollVisibilityObserver } from \'./scroll.types\';\\n\\n  /**\\n   * Wrapper for elements contained in the {@link MainScroll} that should store/restore its\\n   * position.\\n   *\\n   * @public\\n   */\\n  @Component({\\n    mixins: [xComponentMixin(scrollXModule)]\\n  })\\n  export default class MainScrollItem extends Vue {\\n    /**\\n     * Rendered HTML node.\\n     *\\n     * @public\\n     */\\n    public $el!: HTMLElement;\\n\\n    /**\\n     * The item data. Used to set the scroll identifier.\\n     *\\n     * @public\\n     */\\n    @Prop({ required: true })\\n    public item!: Identifiable;\\n\\n    /**\\n     * The tag to render.\\n     *\\n     * @public\\n     */\\n    @Prop({ default: () => NoElement })\\n    public tag!: string | typeof Vue;\\n\\n    /**\\n     * Pending identifier scroll position to restore. If it matches the {@link MainScrollItem.item}\\n     * `id` property, this component should be scrolled into view.\\n     *\\n     * @internal\\n     */\\n    @State(\'scroll\', \'pendingScrollTo\')\\n    public pendingScrollTo!: string;\\n\\n    /**\\n     * Observer to detect the first visible element.\\n     *\\n     * @internal\\n     */\\n    @XInject(ScrollObserverKey)\\n    public firstVisibleItemObserver!: ScrollVisibilityObserver | null;\\n\\n    /**\\n     * Initialise scroll behavior.\\n     * - Observes the rendered element to detect if it is the first visible item.\\n     * - If the rendered element matches the {@link MainScrollItem.pendingScrollTo}, scrolls the\\n     * element into the first position of the view.\\n     *\\n     * @internal\\n     */\\n    async mounted(): Promise<void> {\\n      await this.$nextTick(); // Mounted does not guarantee that child components are mounted too\\n      // eslint-disable-next-line @typescript-eslint/unbound-method\\n      this.$watch(\'firstVisibleItemObserver\', this.observeItem, { immediate: true });\\n    }\\n\\n    /**\\n     * Detaches the observer from the rendered element to prevent memory leaks.\\n     *\\n     * @internal\\n     */\\n    beforeDestroy(): void {\\n      this.firstVisibleItemObserver?.unobserve(this.$el);\\n    }\\n\\n    /**\\n     * Initialises the element visibility observation, stopping the previous one if it has.\\n     *\\n     * @param newObserver - The new observer for the HTML element.\\n     * @param oldObserver - The old observer for the HTML element.\\n     */\\n    observeItem(\\n      newObserver: ScrollVisibilityObserver | null,\\n      oldObserver: ScrollVisibilityObserver | null\\n    ): void {\\n      oldObserver?.unobserve(this.$el);\\n      newObserver?.observe(this.$el);\\n      if (this.pendingScrollTo === this.item.id) {\\n        this.$el.scrollIntoView();\\n        this.$x.emit(\'ScrollRestoreSucceeded\');\\n      }\\n    }\\n  }\\n<\/script>\\n\\n<docs lang=\\"mdx\\">\\n## Events\\n\\nThis components emits the following events:\\n\\n- [`ScrollRestoreSucceeded`](./../../api/x-components.scrollxevents.md)\\n\\n## See it in action\\n\\nThis component has no predefined template. It renders whatever you decide using the `tag` prop. It\'s\\nmain purpose is to help storing and restoring the scroll position so URLs can be shared, and also to\\nallow users to smoothly navigate back and forth.\\n\\nTo do so, it must be wrapped with the `MainScroll` component. In the following example we make use\\nof all of these components. The URL is modified as the user scrolls.\\n\\n```vue\\n<template>\\n  <div>\\n    <UrlHandler />\\n    <SearchInput />\\n\\n    <MainScroll>\\n      <Scroll>\\n        <ResultsList #result=\\"{ item }\\">\\n          <MainScrollItem :item=\\"item\\" tag=\\"article\\">\\n            <BaseResultLink :item=\\"item\\">\\n              <img :src=\\"item.images[0]\\" />\\n              <p>{{ item.title }}</p>\\n            </BaseResultLink>\\n          </MainScrollItem>\\n        </ResultsList>\\n      </Scroll>\\n    </MainScroll>\\n  </div>\\n</template>\\n\\n<script>\\n  import { MainScroll, Scroll, MainScrollItem } from \'@empathyco/x-components/scroll\';\\n  import { ResultsList } from \'@empathyco/x-components/search\';\\n  import { SearchInput } from \'@empathyco/x-components/search-box\';\\n  import { UrlHandler } from \'@empathyco/x-components/url\';\\n\\n  export default {\\n    name: \'ScrollItemDemo\',\\n    components: {\\n      Scroll,\\n      ResultsList,\\n      MainScroll,\\n      MainScrollItem,\\n      SearchInput,\\n      UrlHandler\\n    }\\n  };\\n<\/script>\\n```\\n</docs>\\n"],"names":["const"],"mappings":";;;;AAEAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}')}}]);