(window.webpackJsonp=window.webpackJsonp||[]).push([[981],{1252:function(e,n){throw new Error('Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {"version":3,"file":"device-detector.vue.js","sources":["../../../../../src/x-modules/device/components/device-detector.vue"],"sourcesContent":["<template>\\n  <GlobalEvents v-if=\\"!force\\" @resize=\\"throttledStoreWindowWidth\\" target=\\"window\\" />\\n</template>\\n\\n<script lang=\\"ts\\">\\n  import Vue from \'vue\';\\n  import GlobalEvents from \'vue-global-events\';\\n  import { Component, Prop, Watch } from \'vue-property-decorator\';\\n  import { xComponentMixin } from \'../../../components/x-component.mixin\';\\n  import { XEmit } from \'../../../components/decorators/bus.decorators\';\\n  import { throttle } from \'../../../utils/throttle\';\\n  import { deviceXModule } from \'../x-module\';\\n\\n  /** Alias just to improve code readiness. */\\n  type Device = string;\\n  /** Alias just to improve code readiness. */\\n  type MaxWidth = number;\\n\\n  /**\\n   * This component helps detecting or setting a device, that can be used later to create\\n   * different layouts optimized for different devices. This detected device is available under\\n   * the {@link XComponentAliasAPI.device} property.\\n   *\\n   * @public\\n   */\\n  @Component({\\n    mixins: [xComponentMixin(deviceXModule)],\\n    components: {\\n      GlobalEvents\\n    }\\n  })\\n  export default class DeviceDetector extends Vue {\\n    /**\\n     * Record of the device name, that can be whatever you want `xs`, `mobile`, `big`... And\\n     * the max width in pixels for that device.\\n     *\\n     * @public\\n     */\\n    @Prop({ default: () => ({}) })\\n    public readonly breakpoints!: Record<Device, MaxWidth>;\\n\\n    /**\\n     * Forces a device, ignoring the {@link DeviceDetector.breakpoints} prop.\\n     *\\n     * @public\\n     */\\n    @Prop()\\n    public readonly force?: Device;\\n\\n    /**\\n     * Time in milliseconds to throttle the resize events used to detect the device.\\n     *\\n     * @public\\n     */\\n    @Prop({ default: 100 })\\n    public readonly throttleMs!: number;\\n\\n    /**\\n     * The width in pixels of the window where the app is being rendered.\\n     *\\n     * @internal\\n     */\\n    protected windowWidthPx: number | null = null;\\n\\n    /**\\n     * Throttled version of {@link DeviceDetector.storeWindowWidth} function.\\n     *\\n     * @internal\\n     */\\n    // eslint-disable-next-line @typescript-eslint/unbound-method\\n    protected throttledStoreWindowWidth = this.storeWindowWidth;\\n\\n    /**\\n     * List of each of the entries of the breakpoints sorted from the smallest to the biggest\\n     * max width.\\n     *\\n     * @returns A list of the breakpoints sorted by its max width in ascending order.\\n     *\\n     * @internal\\n     */\\n    protected get sortedBreakpoints(): [Device, MaxWidth][] {\\n      return Object.entries(this.breakpoints).sort(([, aWidth], [, bWidth]) => aWidth - bWidth);\\n    }\\n\\n    /**\\n     * The device detected by this component, or the value provided in {@link DeviceDetector.force}\\n     * prop.\\n     *\\n     * @returns The detected device, or the value provided in {@link DeviceDetector.force}\\n     * prop.\\n     *\\n     * @internal\\n     */\\n    @XEmit(\'DeviceProvided\')\\n    public get detectedDevice(): string | null {\\n      if (this.force) {\\n        return this.force;\\n      } else if (this.windowWidthPx === null) {\\n        return null;\\n      } else {\\n        return (\\n          this.sortedBreakpoints.find(([, width]) => this.windowWidthPx! <= width)?.[0] ?? null\\n        );\\n      }\\n    }\\n\\n    /**\\n     * Stores the window width in {@link DeviceDetector.windowWidthPx}.\\n     *\\n     * @internal\\n     */\\n    protected storeWindowWidth(): void {\\n      this.windowWidthPx = window.innerWidth;\\n    }\\n\\n    /**\\n     * Updates {@link DeviceDetector.throttledStoreWindowWidth} with the throttle time at\\n     * {@link DeviceDetector.throttleMs}.\\n     *\\n     * @param throttleMs - The new duration in milliseconds for the throttle.\\n     *\\n     * @internal\\n     */\\n    @Watch(\'throttleMs\', { immediate: true })\\n    protected updateThrottledStoreWindowWidth(throttleMs: number): void {\\n      // eslint-disable-next-line @typescript-eslint/unbound-method\\n      this.throttledStoreWindowWidth = throttle(this.storeWindowWidth, throttleMs);\\n    }\\n\\n    /**\\n     * Initialises the store window width.\\n     *\\n     * @remarks This is done this way to ensure SSR compatibility.\\n     *\\n     * @internal\\n     */\\n    mounted(): void {\\n      this.storeWindowWidth();\\n    }\\n  }\\n<\/script>\\n\\n<docs lang=\\"mdx\\">\\n## Events\\n\\nThis component emits the following events:\\n\\n- [`DeviceProvided`](./../../api/x-components.devicexevents.md)\\n\\n## See it in action\\n\\nThis component renders no element to the DOM, but serves as way to safely detect or set the device\\nname given an object containing all the possible breakpoints.\\n\\n_Try resizing the browser window!_\\n\\n```vue\\n<template>\\n  <div>\\n    <DeviceDetector :breakpoints=\\"breakpoints\\" />\\n    {{ $x.device }}\\n  </div>\\n</template>\\n\\n<script>\\n  import { DeviceDetector } from \'@empathyco/x-components/device\';\\n\\n  export default {\\n    name: \'DeviceDemo\',\\n    components: {\\n      DeviceDetector\\n    },\\n    data() {\\n      return {\\n        breakpoints: {\\n          mobile: 600,\\n          tablet: 900,\\n          desktop: Number.POSITIVE_INFINITY\\n        }\\n      };\\n    }\\n  };\\n<\/script>\\n```\\n\\n### Play with props\\n\\nIn this example, the `DeviceDetector` has been forced to always detect the `mobile` device. No\\nmatter what the window width is.\\n\\n_Try resizing the window to check that it never changes_\\n\\n```vue\\n<template>\\n  <div>\\n    <DeviceDetector force=\\"mobile\\" :breakpoints=\\"breakpoints\\" />\\n    {{ $x.device }}\\n  </div>\\n</template>\\n\\n<script>\\n  import { DeviceDetector } from \'@empathyco/x-components/device\';\\n\\n  export default {\\n    name: \'DeviceDemo\',\\n    components: {\\n      DeviceDetector\\n    },\\n    data() {\\n      return {\\n        breakpoints: {\\n          mobile: 600,\\n          tablet: 900,\\n          desktop: Number.POSITIVE_INFINITY\\n        }\\n      };\\n    }\\n  };\\n<\/script>\\n```\\n\\n### Play with events\\n\\nIn this example, the `DeviceDetector` will emit a `DeviceProvided` event, with the new device as the\\npayload. This device is stored in a data variable and then displayed.\\n\\n_Try resizing the browser window!_\\n\\n```vue\\n<template>\\n  <div>\\n    <DeviceDetector :breakpoints=\\"breakpoints\\" @DeviceProvided=\\"storeDevice\\" />\\n    {{ device }}\\n  </div>\\n</template>\\n\\n<script>\\n  import { DeviceDetector } from \'@empathyco/x-components/device\';\\n\\n  export default {\\n    name: \'DeviceDemo\',\\n    components: {\\n      DeviceDetector\\n    },\\n    data() {\\n      return {\\n        device: \'unknown\',\\n        breakpoints: {\\n          mobile: 600,\\n          tablet: 900,\\n          desktop: Number.POSITIVE_INFINITY\\n        }\\n      };\\n    },\\n    methods: {\\n      storeDevice(device) {\\n        this.device = device;\\n      }\\n    }\\n  };\\n<\/script>\\n```\\n</docs>\\n"],"names":["const"],"mappings":";;;;AAEAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}')}}]);