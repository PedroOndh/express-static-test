(window.webpackJsonp=window.webpackJsonp||[]).push([[935],{1211:function(A,e){throw new Error('Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {"version":3,"file":"infinite-scroll.js","sources":["../../../../src/directives/infinite-scroll/infinite-scroll.ts"],"sourcesContent":["import { DirectiveOptions } from \'vue\';\\nimport { Vue } from \'vue/types/vue\';\\nimport { InfiniteScroll, ObserverOptions } from \'./infinite-scroll.types\';\\n\\nconst VIEWPORT_ID = \'viewport\';\\n\\n/**\\n * A record which contains {@link IntersectionObserver} objects indexed by the id of the scrollable\\n * container.\\n */\\nconst state: Record<string, IntersectionObserver> = {};\\n\\n/**\\n * Custom Vue directive for infinite scroll.\\n *\\n * This directive uses the IntersectionObserver API to handle the intersection between the\\n * children and the scrollable container. The content of the children moves up on scroll and when it\\n * reaches the end the IntersectionObserver triggers that both elements are intersecting.\\n *\\n * How it works.\\n *\\n * As a summary, if the scroll reaches the end, the `vNode.context.onInfiniteScrollEnd` function\\n * implemented by the component which imports the directive, is executed. If you provide a margin in\\n * the directive options, this function is triggered when the scroll reaches the end minus that\\n * amount of pixels. A default margin of 200px is set.\\n *\\n * Usage.\\n *\\n * The directive has to be set in the target element. It can receive an argument which will be used\\n * to determine the scrollable container. Possible values:\\n * * html: will set the <html> as the scrollable container.\\n * * body: will set the <body> as the scrollable container.\\n * * id: will set the DOM element with the provided id as the scrollable container.\\n *\\n * If no argument is provided the scrollable container fallbacks to the viewport.\\n *\\n * @example How to use it.\\n *\\n * ```html\\n *  <ResultsList v-infinite-scroll:html>\\n * ```\\n *\\n * ```html\\n *  <ResultsList v-infinite-scroll:body>\\n * ```\\n *\\n * ```html\\n *  <BaseScroll id=\'scroll-test\'>\\n *    <ResultsList v-infinite-scroll:scroll-test>\\n *  </BaseScroll>\\n * ```\\n *\\n * ```html\\n *  <ResultsList v-infinite-scroll=\\"{ margin: 40 }\\">\\n * ```\\n *\\n * @public\\n */\\nexport const infiniteScroll: DirectiveOptions = {\\n  inserted(element, { arg: id = VIEWPORT_ID, value: { margin = 200 } = {} }, vNode) {\\n    const root = getRoot(id);\\n\\n    state[id] = createIntersectionObserver({\\n      root,\\n      margin,\\n      vNode\\n    });\\n\\n    state[id].observe(element);\\n  },\\n\\n  unbind(_element, { arg: id = VIEWPORT_ID }) {\\n    if (state[id]) {\\n      state[id].disconnect();\\n      delete state[id];\\n    }\\n  }\\n};\\n\\n/**\\n * Retrieves the root element for the provided id.\\n *\\n * @param id - String.\\n * @returns HTMLElement or null.\\n * */\\nfunction getRoot(id: string): HTMLElement | null {\\n  switch (id) {\\n    case \'html\':\\n      return null;\\n    case \'body\':\\n      return document.body;\\n    case VIEWPORT_ID:\\n      return null;\\n    default:\\n      return document.getElementById(id)!;\\n  }\\n}\\n\\n/**\\n * Creates an IntersectionObserver.\\n *\\n * When the observer is fired, it will execute the {@link InfiniteScroll.onInfiniteScrollEnd}\\n * function implemented in the provided vNode component instance.\\n *\\n * @param options - ObserverOptions.\\n * @returns IntersectionObserver.\\n */\\nfunction createIntersectionObserver({\\n  root,\\n  margin,\\n  vNode\\n}: ObserverOptions): IntersectionObserver {\\n  // This hack allows the root element to always contain the observed element.\\n  // not overpass the top margin more than 1700000 because it doesn\'t work in Android chrome\\n  const rootMargin = `1000000% 0px ${margin}px 0px`;\\n\\n  return new IntersectionObserver(\\n    ([entry]) => {\\n      if (entry.isIntersecting) {\\n        (vNode.componentInstance as Vue & InfiniteScroll)?.onInfiniteScrollEnd();\\n      }\\n    },\\n    {\\n      threshold: 0.99,\\n      rootMargin,\\n      root\\n    }\\n  );\\n}\\n"],"names":[],"mappings":"AAIA,IAAM,WAAW,GAAG,UAAU,CAAC;AAE/B;;;;AAIA,IAAM,KAAK,GAAyC,EAAE,CAAC;AAEvD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA8Ca,cAAc,GAAqB;IAC9C,QAAQ,YAAC,OAAO,EAAE,EAAuD,EAAE,KAAK;YAA5D,WAAqB,EAAhB,EAAE,mBAAG,WAAW,KAAA,EAAE,aAA4B,EAA5B,qBAA0B,EAAE,KAAA,EAAnB,cAAY,EAAZ,MAAM,mBAAG,GAAG,KAAA;QAC9D,IAAM,IAAI,GAAG,OAAO,CAAC,EAAE,CAAC,CAAC;QAEzB,KAAK,CAAC,EAAE,CAAC,GAAG,0BAA0B,CAAC;YACrC,IAAI,MAAA;YACJ,MAAM,QAAA;YACN,KAAK,OAAA;SACN,CAAC,CAAC;QAEH,KAAK,CAAC,EAAE,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;KAC5B;IAED,MAAM,YAAC,QAAQ,EAAE,EAAyB;YAAvB,WAAqB,EAAhB,EAAE,mBAAG,WAAW,KAAA;QACtC,IAAI,KAAK,CAAC,EAAE,CAAC,EAAE;YACb,KAAK,CAAC,EAAE,CAAC,CAAC,UAAU,EAAE,CAAC;YACvB,OAAO,KAAK,CAAC,EAAE,CAAC,CAAC;SAClB;KACF;EACD;AAEF;;;;;;AAMA,SAAS,OAAO,CAAC,EAAU;IACzB,QAAQ,EAAE;QACR,KAAK,MAAM;YACT,OAAO,IAAI,CAAC;QACd,KAAK,MAAM;YACT,OAAO,QAAQ,CAAC,IAAI,CAAC;QACvB,KAAK,WAAW;YACd,OAAO,IAAI,CAAC;QACd;YACE,OAAO,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAE,CAAC;KACvC;AACH,CAAC;AAED;;;;;;;;;AASA,SAAS,0BAA0B,CAAC,EAIlB;QAHhB,IAAI,UAAA,EACJ,MAAM,YAAA,EACN,KAAK,WAAA;;;IAIL,IAAM,UAAU,GAAG,kBAAgB,MAAM,WAAQ,CAAC;IAElD,OAAO,IAAI,oBAAoB,CAC7B,UAAC,EAAO;;YAAN,KAAK,QAAA;QACL,IAAI,KAAK,CAAC,cAAc,EAAE;YACxB,MAAC,KAAK,CAAC,iBAA0C,0CAAE,mBAAmB,EAAE,CAAC;SAC1E;KACF,EACD;QACE,SAAS,EAAE,IAAI;QACf,UAAU,YAAA;QACV,IAAI,MAAA;KACL,CACF,CAAC;AACJ;;;;"}')}}]);