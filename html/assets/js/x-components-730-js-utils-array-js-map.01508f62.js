(window.webpackJsonp=window.webpackJsonp||[]).push([[952],{1227:function(e,A){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"array.js\",\"sources\":[\"../../../src/utils/array.ts\"],\"sourcesContent\":[\"import { PropsWithType } from './types';\\n\\n/**\\n * Returns if the given array is `null`, `undefined`, or has no elements.\\n *\\n * @param array - The array to check if it is empty.\\n * @returns `true` if the array is `null`, `undefined`, or has no elements. `false` otherwise.\\n * @public\\n */\\nexport function isArrayEmpty(array: unknown[] | undefined | null): array is undefined | null | [] {\\n  return array == null || array.length === 0;\\n}\\n\\n/**\\n * Reduce an array of strings to an object which properties names are the value of each string,\\n * and the value under that property are also the string.\\n *\\n * @param array - Array of strings that will be used to create the object.\\n *\\n * @returns New object which properties object[key] contains object of each iteration in the\\n * array.\\n *\\n * @example Converting an array to an object:\\n *         arrayToObject(['a', 'b', 'c']) === \\\\{a: 'a', b: 'b', c: 'c'\\\\}\\n *\\n * @public\\n */\\nexport function arrayToObject(array: string[]): Record<string, string>;\\n/**\\n * Reduce an array of objects to an object which properties names are the value of each object[key],\\n * and the value under that property are each object. 'key' is the the parameter passed to this\\n * function.\\n *\\n * @param array - Array of objects that contains objects which have object[key] string as a property\\n * value.\\n * @param key - Key used to access to each object[key] value, used for each property name in the new\\n * object.\\n *\\n * @returns New object which properties object[key] contains object of each iteration in the array.\\n *\\n * @public\\n */\\nexport function arrayToObject<ArrayType, KeyType extends string | number>(\\n  array: ArrayType[],\\n  key: PropsWithType<ArrayType, KeyType>\\n): Record<string, ArrayType>;\\n/**\\n * Reduce an array to an object. The type of the object returned depends on the type of the params.\\n * If the 'key' is passed then the function returns an object which properties names are the value\\n * of each object[key] and the value under that property are each object.\\n * If the 'key' is not passed then the function returns an object which properties names are each\\n * array item, and the value is also the array item.\\n *\\n * @param array - Array from which to create an object.\\n * @param key - Key used to access to each object[key] value, used for each property name in the\\n * new object.\\n *\\n * @returns New object which properties object[key] contains each item in the array and the key is\\n * either the item of the array or a property of each item designated by 'key' param.\\n *\\n * @public\\n */\\nexport function arrayToObject<ArrayType, KeyType extends string | number>(\\n  array: ArrayType[],\\n  key?: PropsWithType<ArrayType, KeyType>\\n): Record<string, ArrayType> {\\n  return array.reduce<Record<string, ArrayType>>((accumulator, current) => {\\n    if (key) {\\n      accumulator[current[key] as unknown as string] = current;\\n    } else if (typeof current === 'string') {\\n      accumulator[current] = current;\\n    }\\n    return accumulator;\\n  }, {});\\n}\\n\\n/**\\n * Groups the array items based on the provided `groupBy` function.\\n *\\n * @param array - The array to iterate, grouping its items in different arrays based on the\\n * `groupBy` function.\\n * @param groupBy - A function to determine the group name of a single item.\\n * @returns The items grouped in a dictionary.\\n *\\n * @public\\n */\\nexport function groupItemsBy<ArrayType, ReturnType extends string | number>(\\n  array: ArrayType[],\\n  groupBy: (item: ArrayType, index: number) => ReturnType\\n): Record<ReturnType, ArrayType[]> {\\n  return array.reduce<Record<ReturnType, ArrayType[]>>((accumulator, current, index) => {\\n    const keyValue = groupBy(current, index);\\n    if (!accumulator[keyValue]) {\\n      accumulator[keyValue] = [];\\n    }\\n    accumulator[keyValue].push(current);\\n    return accumulator;\\n  }, {} as Record<ReturnType, ArrayType[]>);\\n}\\n\\n/**\\n * Filters an array with all elements that pass the test implemented by the provided filter\\n * function. It also does it recursively if the property accessed, whose name is the parameter\\n * childrenKey, to the current iteration in an array.\\n *\\n * @param array - Array to be filtered.\\n * @param filter - Predicate function to test each element of the array. It should return true\\n * to keep the element; or false otherwise.\\n * @param childrenKey - Property name within the array used to perform a recursive call.\\n *\\n * @example\\n * Input - Output example\\n *\\n * ```\\n * const hierarchicalFilters: Filter[] = [\\n *   {\\n *     id: 'filter1'\\n *     selected: true,\\n *     children: [\\n *       {\\n *         id: 'filter1-1'\\n *         selected: true,\\n *         children: []\\n *       },\\n *       {\\n *         id: 'filter1-2'\\n *         selected: false,\\n *         children: []\\n *       }\\n *     ]\\n *   },\\n *   {\\n *     id: 'filter2',\\n *     selected: false,\\n *     children: [\\n *      {\\n *        id: 'filter2-1',\\n *        selected: true // not should happen\\n *      }\\n *     ]\\n *   }\\n * ]\\n *\\n *  const filteredArray: Filter[] = deepFilterArray(\\n *    hierarchicalFilters,\\n *    filter => filter.selected,\\n *    'children'\\n *  )\\n *\\n *  /*\\n *    filteredArray = [\\n *      {\\n *        id: 'filter1'\\n *        selected: true,\\n *        children: [\\n *          {\\n *            id: 'filter1-1'\\n *            selected: true,\\n *            children: []\\n *          },\\n *          {\\n *            id: 'filter1-2'\\n *            selected: false,\\n *            children: []\\n *          }\\n *        ]\\n *      },\\n *      {\\n *        id: 'filter1-1'\\n *        selected: true,\\n *        children: []\\n *      }\\n *    ]\\n * ```\\n *\\n * @returns A new array with the elements that pass the test, or an empty array if no one\\n * pass the test.\\n *\\n * @public\\n */\\nexport function deepFilter<ArrayType, Key extends PropsWithType<ArrayType, ArrayType[]>>(\\n  array: ArrayType[],\\n  filter: (item: ArrayType) => boolean,\\n  childrenKey: Key\\n): ArrayType[] {\\n  const filterArray = function (\\n    currentArray: ArrayType[],\\n    initialArray: ArrayType[] = []\\n  ): ArrayType[] {\\n    return currentArray.reduce((result, currentItem) => {\\n      if (filter(currentItem)) {\\n        result.push(currentItem);\\n        filterArray(currentItem[childrenKey], result);\\n      }\\n\\n      return result;\\n    }, initialArray);\\n  };\\n\\n  return filterArray(array);\\n}\\n\\n/**\\n * Flat an ArrayType[] recursively using the childrenKey passed as parameter to access to his nested\\n * child which is also ArrayType[].\\n *\\n * @param array - ArrayType[] which each ArrayType has a property childrenKey which value is also\\n * an ArrayType[].\\n * @param childrenKey - Key used to access to each ArrayType[childrenKey] value which is also\\n * an ArrayType[].\\n *\\n * @returns ArrayType[] with all the nested ArrayType, including the nested ones, at the same depth\\n * level.\\n *\\n * @public\\n */\\nexport function deepFlat<ArrayType, Key extends PropsWithType<ArrayType, ArrayType[] | undefined>>(\\n  array: ArrayType[],\\n  childrenKey: Key\\n): ArrayType[] {\\n  /**\\n   * Flats an array recursively. In each iteration:\\n   * - If the currentItem is an array, flatArray is used to reduce it. So, the order of the\\n   * flatArray arguments defined is important. This happens when the function is called passing an\\n   * array as the second parameter.\\n   * - If not, the item is pushed to the resultantArray.\\n   * - Finally, flatArray function is called again with the currentItem children and the process\\n   * starts again.\\n   *\\n   * It's the main function of the parent. See the description above\\n   * for further information.\\n   *\\n   * @param resultantArray - Flattened array.\\n   * @param currentItem - ArrayType object.\\n   *\\n   * @returns Flattened ArrayType[].\\n   *\\n   * @internal\\n   */\\n  function flatArray(\\n    resultantArray: ArrayType[],\\n    currentItem: ArrayType | ArrayType[]\\n  ): ArrayType[] {\\n    if (!currentItem) {\\n      return resultantArray;\\n    }\\n\\n    if (Array.isArray(currentItem)) {\\n      return currentItem.reduce(flatArray, resultantArray);\\n    }\\n    resultantArray.push(currentItem);\\n    return flatArray(resultantArray, currentItem[childrenKey]);\\n  }\\n\\n  return flatArray([], array);\\n}\\n\\n/**\\n * Creates an Emitter filter function to compare two arrays and filter those that are equal.\\n *\\n * @param comparator - String with the name of the field of the arrays items to compare, or function\\n * to compare items directly.\\n * @returns The comparator function that receives two arrays to compare them.\\n *\\n * @internal\\n */\\nexport function createEmitterArrayFilter<T>(\\n  comparator: keyof T | ((item1: T, item2: T) => boolean)\\n): (newCollection: Array<T>, oldCollection: Array<T>) => boolean {\\n  const comparatorFn =\\n    typeof comparator === 'function'\\n      ? comparator\\n      : (newItem: T, oldItem: T) => newItem[comparator] === oldItem[comparator];\\n  return function (newCollection: Array<T>, oldCollection: Array<T>): boolean {\\n    return (\\n      newCollection.length !== oldCollection.length ||\\n      newCollection.some(newItem => !oldCollection.find(oldItem => comparatorFn(newItem, oldItem)))\\n    );\\n  };\\n}\\n\"],\"names\":[],\"mappings\":\"AAEA;;;;;;;SAOgB,YAAY,CAAC,KAAmC;IAC9D,OAAO,KAAK,IAAI,IAAI,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC;AAC7C,CAAC;AAmCD;;;;;;;;;;;;;;;;SAgBgB,aAAa,CAC3B,KAAkB,EAClB,GAAuC;IAEvC,OAAO,KAAK,CAAC,MAAM,CAA4B,UAAC,WAAW,EAAE,OAAO;QAClE,IAAI,GAAG,EAAE;YACP,WAAW,CAAC,OAAO,CAAC,GAAG,CAAsB,CAAC,GAAG,OAAO,CAAC;SAC1D;aAAM,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;YACtC,WAAW,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC;SAChC;QACD,OAAO,WAAW,CAAC;KACpB,EAAE,EAAE,CAAC,CAAC;AACT,CAAC;AAED;;;;;;;;;;SAUgB,YAAY,CAC1B,KAAkB,EAClB,OAAuD;IAEvD,OAAO,KAAK,CAAC,MAAM,CAAkC,UAAC,WAAW,EAAE,OAAO,EAAE,KAAK;QAC/E,IAAM,QAAQ,GAAG,OAAO,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;QACzC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,EAAE;YAC1B,WAAW,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;SAC5B;QACD,WAAW,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACpC,OAAO,WAAW,CAAC;KACpB,EAAE,EAAqC,CAAC,CAAC;AAC5C,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAgFgB,UAAU,CACxB,KAAkB,EAClB,MAAoC,EACpC,WAAgB;IAEhB,IAAM,WAAW,GAAG,UAClB,YAAyB,EACzB,YAA8B;QAA9B,6BAAA,EAAA,iBAA8B;QAE9B,OAAO,YAAY,CAAC,MAAM,CAAC,UAAC,MAAM,EAAE,WAAW;YAC7C,IAAI,MAAM,CAAC,WAAW,CAAC,EAAE;gBACvB,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBACzB,WAAW,CAAC,WAAW,CAAC,WAAW,CAAC,EAAE,MAAM,CAAC,CAAC;aAC/C;YAED,OAAO,MAAM,CAAC;SACf,EAAE,YAAY,CAAC,CAAC;KAClB,CAAC;IAEF,OAAO,WAAW,CAAC,KAAK,CAAC,CAAC;AAC5B,CAAC;AAED;;;;;;;;;;;;;;SAcgB,QAAQ,CACtB,KAAkB,EAClB,WAAgB;;;;;;;;;;;;;;;;;;;;IAqBhB,SAAS,SAAS,CAChB,cAA2B,EAC3B,WAAoC;QAEpC,IAAI,CAAC,WAAW,EAAE;YAChB,OAAO,cAAc,CAAC;SACvB;QAED,IAAI,KAAK,CAAC,OAAO,CAAC,WAAW,CAAC,EAAE;YAC9B,OAAO,WAAW,CAAC,MAAM,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;SACtD;QACD,cAAc,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QACjC,OAAO,SAAS,CAAC,cAAc,EAAE,WAAW,CAAC,WAAW,CAAC,CAAC,CAAC;KAC5D;IAED,OAAO,SAAS,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;AAC9B,CAAC;AAED;;;;;;;;;SASgB,wBAAwB,CACtC,UAAuD;IAEvD,IAAM,YAAY,GAChB,OAAO,UAAU,KAAK,UAAU;UAC5B,UAAU;UACV,UAAC,OAAU,EAAE,OAAU,IAAK,OAAA,OAAO,CAAC,UAAU,CAAC,KAAK,OAAO,CAAC,UAAU,CAAC,GAAA,CAAC;IAC9E,OAAO,UAAU,aAAuB,EAAE,aAAuB;QAC/D,QACE,aAAa,CAAC,MAAM,KAAK,aAAa,CAAC,MAAM;YAC7C,aAAa,CAAC,IAAI,CAAC,UAAA,OAAO,IAAI,OAAA,CAAC,aAAa,CAAC,IAAI,CAAC,UAAA,OAAO,IAAI,OAAA,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,GAAA,CAAC,GAAA,CAAC,EAC7F;KACH,CAAC;AACJ;;;;\"}")}}]);