(window.webpackJsonp=window.webpackJsonp||[]).push([[610],{1025:function(n,e){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"base-keyboard-navigation.vue.js\",\"sources\":[\"../../../src/components/base-keyboard-navigation.vue\"],\"sourcesContent\":[\"<template>\\n  <div\\n    @keydown.up.down.right.left.prevent=\\\"focusNextNavigableElement\\\"\\n    class=\\\"x-keyboard-navigation\\\"\\n    data-test=\\\"keyboard-navigation\\\"\\n  >\\n    \x3c!-- @slot (Required) Container content --\x3e\\n    <slot />\\n  </div>\\n</template>\\n\\n<script lang=\\\"ts\\\">\\n  import Vue from 'vue';\\n  import { Component, Prop } from 'vue-property-decorator';\\n  // eslint-disable-next-line max-len\\n  import { DirectionalFocusNavigationService } from '../services/directional-focus-navigation.service';\\n  import { SpatialNavigation } from '../services/services.types';\\n  import { ArrowKey, EventsForDirectionLimit, TakeNavigationControl } from '../utils/types';\\n  import { XEventsOf } from '../wiring/events.types';\\n  import { WireMetadata } from '../wiring/wiring.types';\\n  import { XOn } from './decorators/bus.decorators';\\n\\n  /**\\n   * Base component to handle keyboard navigation for elements inside it. It has a required slot to\\n   * include the navigable elements.\\n   *\\n   * @remarks\\n   * The component can be customized through props: an array of navigationHijacker objects, which\\n   * contains: the xEvent to listen to, the moduleName in charge of emitting the event and to which\\n   * direction it should react to; to take control of the navigation and eventsForDirectionLimit, to\\n   * emit an xEvent when reaching the navigation limit in any direction.\\n   *\\n   * @public\\n   */\\n  @Component\\n  export default class BaseKeyboardNavigation extends Vue {\\n    /**\\n     * An array of {@link TakeNavigationControl | navigation hijacker} objects defining when to\\n     * take control of the keyboard navigation.\\n     */\\n    @Prop({\\n      default: () => [\\n        { xEvent: 'UserPressedArrowKey', moduleName: 'searchBox', direction: 'ArrowDown' }\\n      ]\\n    })\\n    protected navigationHijacker!: TakeNavigationControl[];\\n\\n    /**\\n     * An {@link EventsForDirectionLimit} to emit when the user is already at the furthest element\\n     * in a direction and tries to keep going on the same direction.\\n     */\\n    @Prop({ default: () => ({ ArrowUp: 'UserReachedEmpathizeTop' }) })\\n    protected eventsForDirectionLimit!: Partial<EventsForDirectionLimit>;\\n\\n    /**\\n     * The {@link SpatialNavigation | navigation service} to use.\\n     */\\n    protected navigationService!: SpatialNavigation;\\n\\n    /**\\n     * The element to focus.\\n     */\\n    protected elementToFocus: HTMLElement | undefined;\\n\\n    mounted(): void {\\n      // TODO Replace this with injection\\n      this.navigationService = new DirectionalFocusNavigationService(this.$el as HTMLElement);\\n    }\\n\\n    /**\\n     * Get the navigation hijacker events.\\n     *\\n     * @remarks\\n     * If the same {@link XEvent} is defined multiple times it is only inserted once.\\n     *\\n     * @returns The events to hijack the navigation.\\n     */\\n    protected get navigationHijackerEvents(): XEventsOf<ArrowKey>[] {\\n      const eventsSet = this.navigationHijacker.map(({ xEvent }) => xEvent);\\n      return Array.from(new Set(eventsSet));\\n    }\\n\\n    /**\\n     * Trigger navigation if this component is in control of it.\\n     *\\n     * @param eventPayload - The {@link WirePayload.eventPayload}.\\n     * @param metadata - The {@link WirePayload.metadata}.\\n     * @public\\n     */\\n    @XOn(component => (component as BaseKeyboardNavigation).navigationHijackerEvents)\\n    triggerNavigation(eventPayload: ArrowKey, metadata: WireMetadata): void {\\n      if (this.hasToTakeNavigationControl(eventPayload, metadata)) {\\n        this.focusNextNavigableElement(eventPayload);\\n      }\\n    }\\n\\n    /**\\n     * Checks if the component has to take control of the keyboard navigation.\\n     *\\n     * @param eventPayload - The {@link ArrowKey}.\\n     * @param metadata - The {@link WireMetadata}.\\n     *\\n     * @returns Whether the component needs to take control of the keyboard navigation or not.\\n     * @internal\\n     */\\n    private hasToTakeNavigationControl(eventPayload: ArrowKey, metadata: WireMetadata): boolean {\\n      return this.navigationHijacker.some(\\n        ({ moduleName, direction }) =>\\n          moduleName === metadata.moduleName && direction === eventPayload\\n      );\\n    }\\n\\n    /**\\n     * Focus the next navigable element returned by the navigation service.\\n     *\\n     * @param direction - The navigation direction.\\n     * @internal\\n     */\\n    protected focusNextNavigableElement(direction: ArrowKey | KeyboardEvent): void {\\n      const dir = typeof direction === 'object' ? (direction.key as ArrowKey) : direction;\\n      const nextElementToFocus = this.navigationService?.navigateTo(dir);\\n\\n      if (this.elementToFocus !== nextElementToFocus) {\\n        this.elementToFocus = nextElementToFocus;\\n        this.elementToFocus.focus();\\n      } else {\\n        this.emitDirectionalLimitReached(dir);\\n        this.elementToFocus = undefined;\\n      }\\n    }\\n\\n    /**\\n     * Emit the {@link XEvent} associated to the navigation's direction when reaching its limit.\\n     *\\n     * @param direction - The navigation direction.\\n     * @internal\\n     */\\n    private emitDirectionalLimitReached(direction: ArrowKey): void {\\n      const xEvent = this.eventsForDirectionLimit?.[direction];\\n      if (xEvent) {\\n        this.$x.emit(xEvent, undefined, { target: this.elementToFocus });\\n      }\\n    }\\n  }\\n<\/script>\\n\\n<docs lang=\\\"mdx\\\">\\n## Examples\\n\\nThis component has a slot to inject other components inside it. The component expects a required\\nprop, navigationHijacker, which is an array of objects containing: the xEvent to listen to, the\\nmoduleName in charge of emitting the event and to which direction it should react to; to take\\ncontrol of the navigation. It has another prop, optional in this case, to emit an xEvent when\\nreaching the navigation limit in any direction.\\n\\n### Basic Usage\\n\\n```vue\\n<KeyboardNavigation>\\n  <QuerySuggestions/>\\n</KeyboardNavigation>\\n```\\n\\n### Defining multiple conditions to take navigation's control\\n\\n```vue\\n<KeyboardNavigation\\n  :navigationHijacker=\\\"[\\n    {\\n      xEvent: 'UserPressedArrowKey',\\n      moduleName: 'searchBox',\\n      direction: 'ArrowDown'\\n    },\\n    {\\n      xEvent: 'UserPressedArrowKey',\\n      moduleName: 'facets',\\n      direction: 'ArrowRight'\\n    }\\n  ]\\\"\\n>\\n  <QuerySuggestions/>\\n</KeyboardNavigation>\\n```\\n\\n### Defining events to emit when reaching a navigation limit\\n\\n```vue\\n<KeyboardNavigation\\n  :navigationHijacker=\\\"[\\n    {\\n      xEvent: 'UserPressedArrowKey',\\n      moduleName: 'searchBox',\\n      direction: 'ArrowDown'\\n    }\\n  ]\\\"\\n  :eventsForDirectionLimit=\\\"{\\n    ArrowUp: 'UserReachedEmpathizeTop'\\n  }\\\"\\n>\\n  <QuerySuggestions/>\\n</KeyboardNavigation>\\n```\\n\\n## Events\\n\\nAn event that the component will emit:\\n\\n- `UserReachedEmpathizeTop`: the event emitted by default when the container reaches its top\\n  navigation, but more events can be emitted for each direction using the `eventsForDirectionLimit`\\n  prop.\\n</docs>\\n\"],\"names\":[\"const\"],\"mappings\":\";;;;AAEAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\"}")}}]);