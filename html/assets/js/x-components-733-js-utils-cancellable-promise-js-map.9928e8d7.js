(window.webpackJsonp=window.webpackJsonp||[]).push([[953],{1228:function(e,n){throw new Error('Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {"version":3,"file":"cancellable-promise.js","sources":["../../../src/utils/cancellable-promise.ts"],"sourcesContent":["import { noOp } from \'./function\';\\n/**\\n * Symbol used to know if a promise is cancelled.\\n *\\n * @internal\\n */\\nexport const CancelSymbol = Symbol(\'cancelled-promise\');\\n/**\\n * The type returned by the {@link cancellablePromise} function.\\n *\\n * @internal\\n */\\nexport interface CancellablePromiseFunction<T, K = unknown> {\\n  /**\\n   * The resultant promise that groups the original promise, passed as the first parameter, and the\\n   * promise created in cancellablePromise, which rejects the resultant promise if called.\\n   */\\n  promise: Promise<T>;\\n  /**\\n   * Function to cancel the resultant promise. This function triggers the reject of the second\\n   * promise of the promise race. The first parameter is the resultant promise rejection value.\\n   */\\n  cancel: (payload?: K) => void;\\n}\\n\\n/**\\n * Util function that returns an object which contains a promise, result of Promise.race call\\n * between the original one passed as parameter and another one, created within the function, used\\n * for reject in the resultant promise manually. If the cancel method is triggered, the\\n * resultant promise is rejected.\\n *\\n * @remarks The promise function passed as first param executes its own async code ALWAYS although\\n * it\'s cancelled or not. The payload of the resultant promise is the returned by the function that\\n * ends first. So, the promise is not cancelled exactly. The parameter first passed to cancel is the\\n * resultant promise rejection value.\\n *\\n * If you need to check if the promise is not being rejected with CancelSymbol (on purpose).\\n * You should check the error type in the cancellable catch using the payload.\\n *\\n * @param promise - Original promise.\\n * @param cancelCallback - Optional callback to be called on cancel.\\n * @returns CancellablePromiseFunction {@link CancellablePromiseFunction}.\\n *\\n * @internal\\n */\\nexport function cancellablePromise<T, K = unknown>(\\n  promise: Promise<T>,\\n  cancelCallback?: (payload?: K) => void\\n): CancellablePromiseFunction<T, K> {\\n  let cancel: (payload?: K) => void = noOp;\\n\\n  const cancelPromise = new Promise<never>((_, reject) => {\\n    cancel = payload => {\\n      reject(CancelSymbol);\\n      cancelCallback?.(payload);\\n    };\\n  });\\n\\n  return {\\n    promise: Promise.race([promise, cancelPromise]),\\n    cancel\\n  };\\n}\\n"],"names":[],"mappings":";;AACA;;;;;IAKa,YAAY,GAAG,MAAM,CAAC,mBAAmB,EAAE;AAmBxD;;;;;;;;;;;;;;;;;;;;SAoBgB,kBAAkB,CAChC,OAAmB,EACnB,cAAsC;IAEtC,IAAI,MAAM,GAA0B,IAAI,CAAC;IAEzC,IAAM,aAAa,GAAG,IAAI,OAAO,CAAQ,UAAC,CAAC,EAAE,MAAM;QACjD,MAAM,GAAG,UAAA,OAAO;YACd,MAAM,CAAC,YAAY,CAAC,CAAC;YACrB,cAAc,aAAd,cAAc,uBAAd,cAAc,CAAG,OAAO,CAAC,CAAC;SAC3B,CAAC;KACH,CAAC,CAAC;IAEH,OAAO;QACL,OAAO,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,OAAO,EAAE,aAAa,CAAC,CAAC;QAC/C,MAAM,QAAA;KACP,CAAC;AACJ;;;;"}')}}]);