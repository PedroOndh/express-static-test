(window.webpackJsonp=window.webpackJsonp||[]).push([[753],{1041:function(e,n){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"injection.decorators.js\",\"sources\":[\"../../../../src/components/decorators/injection.decorators.ts\"],\"sourcesContent\":[\"import Vue, { ComponentOptions } from 'vue';\\nimport { createDecorator } from 'vue-class-component';\\nimport { arrayToObject } from '../../utils/array';\\nimport { DecoratorFor } from '../../utils/types';\\n\\n/**\\n * The type of the Vue Component provide configuration, narrowed to the object type.\\n *\\n * @internal\\n */\\n// eslint-disable-next-line @typescript-eslint/ban-types\\ntype ProvideObjectConfig = Exclude<ComponentOptions<Vue>['provide'], (() => object) | undefined>;\\n\\n/**\\n * The type of the Vue Component inject configuration, narrowed to the object type.\\n *\\n * @internal\\n */\\ntype InjectObjectConfig = Exclude<ComponentOptions<Vue>['inject'], string[] | undefined>;\\n\\n/**\\n * Type of the key passed to {@link XProvide} and {@link XInject} to be type-safe. With this type\\n * you can declare the type of the injected value directly in the injection key.\\n *\\n * @example\\n * `const myKey: XInjectKey<Filter> = 'myFilter';`\\n * `@XInject(myKey)`\\n *\\n * @public\\n */\\n// eslint-disable-next-line @typescript-eslint/no-unused-vars-experimental\\nexport interface XInjectKey<Type> extends String {}\\n\\n/**\\n * The union type for the different functions in this module.\\n *\\n * @internal\\n */\\ntype AnyInjectKey<Type> = XInjectKey<Type> | string;\\n\\n/**\\n * Generates a provide function that returns an object with the injectable value returned in a\\n * getter to keep its reactivity, using the default\\n * {@link https://vuejs.org/v2/api/#provide-inject | Vue inject}. It overrides the provide key if\\n * the parent provides the same key.\\n *\\n * @remarks The decorated property needs to be public for type inference to work.\\n *\\n * @param provideKey - The key used to provide. This key can be a 'string' or a 'XInject<Type>'.\\n * This last type is to support type-safe injection. When this decorator is used, it is possible\\n * to specify the type of the injected value. Take a look to the example below.\\n * @returns Decorator with the provide configuration.\\n *\\n * @example\\n * Type unsafe injection (but allowed):\\n *     \\\\@XProvide('myKey')\\n *\\n * Type safe injection (recommended):\\n *     const myKey: XInjectKey<Date> = 'myKey';\\n *     \\\\@XProvide(myKey)\\n *\\n * This last one, you are specifying that the injected value with the key 'myKey' has the Date\\n * type.\\n *\\n * @public\\n */\\nexport function XProvide<Type>(provideKey: AnyInjectKey<Type>): DecoratorFor<Type> {\\n  return createDecorator((options, componentKey) => {\\n    const previousProvide = options.provide;\\n    options.provide = function <ComponentInstance extends Vue>(this: ComponentInstance) {\\n      const previousProvideObject = getPreviousProvideObject(previousProvide, this);\\n      const newProvideObject = getNewProvideObject(provideKey, componentKey, this);\\n      return Object.assign(previousProvideObject, newProvideObject);\\n    };\\n  });\\n}\\n\\n/**\\n * Generates an inject configuration object to inject a value provided by {@link XProvide}.\\n * This function injects the value into a private property of the component instance using the\\n * default {@link https://vuejs.org/v2/api/#provide-inject | Vue inject}. This private property\\n * is named as the decorated property but prefixed with `_x-inject_`.\\n *\\n * Why is this private property necessary? Well, the {@link XProvide} decorator, provides an object\\n * with the shape \\\\{ value: any \\\\} being that value a getter to keep reactivity of the injected\\n * value. This private property is to \\\"shortcut\\\" that object and directly inject the value itself.\\n * Otherwise, you should access to the actual value using `.value`.\\n *\\n * The final step is done by a computed property. This has the same name as the decorated property.\\n * This computed returns the inner value getter of the injected object. This way the decorated\\n * property has finally the initial injected value.\\n *\\n * @remarks The decorated property needs to be public for type inference to work.\\n *\\n * @param injectKey - The key used to inject. This key can be a 'string' or a 'XInject<Type>'.\\n * This last type is to support type-safe injection. When this decorator is used, it is possible\\n * to specify the type of the injected value. Take a look to the example below.\\n * @returns Decorator with the provide configuration.\\n *\\n * @param defaultValue - The default value to use if there is not value provided.\\n *\\n * @example\\n * Type unsafe injection (but allowed):\\n *     \\\\@XInject('myKey')\\n *\\n * Type safe injection (recommended):\\n *     const myKey: XInjectKey<Date> = 'myKey';\\n *     \\\\@XInject(myKey)\\n *\\n * @public\\n */\\nexport function XInject<Type>(\\n  injectKey: AnyInjectKey<Type>,\\n  defaultValue?: Type\\n): DecoratorFor<Type> {\\n  return createDecorator((options, componentKey) => {\\n    const privateComponentKey = `_x-inject_${componentKey}`;\\n    const previousInjectObject = getPreviousInjectObject(options.inject);\\n    const newInjectObject = getNewInjectObject(injectKey, privateComponentKey, defaultValue);\\n    options.inject = Object.assign(previousInjectObject, newInjectObject);\\n    const computedToPrivateProperty = getComputedProperty(componentKey, privateComponentKey);\\n    options.computed = Object.assign(options.computed ?? {}, computedToPrivateProperty);\\n  });\\n}\\n\\n/**\\n * This function receives the previous provide of the component instance.\\n * If the provide is a function, then returns it as an object invoking it with the component\\n * instance.\\n * If the provide is an object then it is returned directly.\\n * If the provide is undefined, then an empty object returned.\\n *\\n * @param previousProvide - The {@link ComponentOptions.provide } configuration that exist before\\n * applying this decorator.\\n * @param componentInstance - A Vue Component instance to invoke the provide function.\\n *\\n * @returns {@link ProvideObjectConfig} With the provide configuration as an object.\\n */\\nfunction getPreviousProvideObject<ComponentInstance extends Vue>(\\n  previousProvide: ComponentOptions<Vue>['provide'],\\n  componentInstance: ComponentInstance\\n): ProvideObjectConfig {\\n  if (isProvideFunction(previousProvide)) {\\n    return previousProvide.call(componentInstance);\\n  } else {\\n    return previousProvide ?? {};\\n  }\\n}\\n\\n/**\\n * This function creates a new provide configuration, wrapping the value to provide inside a getter\\n * called `value`. This is done to keep the reactivity of the injected value.\\n *\\n * @param provideKey - The key of the provide value.\\n * @param componentKey - The name of the property decorated with {@link XProvide}.\\n * @param componentInstance - The {@link Vue} instance of the component to invoke the provide\\n * function.\\n *\\n * @returns {@link ProvideObjectConfig} The object with the key of the provideKey and the `value`\\n * getter.\\n */\\nfunction getNewProvideObject<ComponentInstance extends Vue>(\\n  provideKey: AnyInjectKey<unknown>,\\n  componentKey: string,\\n  componentInstance: ComponentInstance\\n): ProvideObjectConfig {\\n  return {\\n    [provideKey as string]: {\\n      get value() {\\n        return componentInstance[componentKey as keyof ComponentInstance];\\n      }\\n    }\\n  };\\n}\\n\\n/**\\n * This function returns the previous inject config as an object. This will be used to merge it with\\n * the new inject configuration.\\n * If the previous inject config of the component instance is an Array, then it converts it into an\\n * object.\\n * If the previous inject config of the component instance is an object, then it returns it\\n * directly.\\n * If the previous inject config of the component instance is undefined, then an empty object is\\n * returned.\\n *\\n * @param previousInject - The previous inject configuration of the component instance.\\n *\\n * @returns {@link InjectObjectConfig} The object with the previous inject config in form of object.\\n */\\nfunction getPreviousInjectObject(\\n  previousInject: ComponentOptions<Vue>['inject']\\n): InjectObjectConfig {\\n  if (Array.isArray(previousInject)) {\\n    return arrayToObject(previousInject);\\n  } else {\\n    return previousInject ?? {};\\n  }\\n}\\n\\n/**\\n * This function returns the new inject configuration. This will be merged with the previous inject\\n * configuration.\\n * It returns an object with the key and a string if no `defaultValue` is passed. Otherwise it\\n * returns an object with `from` and `default` keys.\\n *\\n * @param injectKey - The key of the injected value.\\n * @param componentKey - The name of the component key where the value will be injected.\\n * @param defaultValue - The default value of the injection if the `injectKey` has no provide.\\n *\\n * @returns The object with the inject configuration.\\n */\\nfunction getNewInjectObject<DefaultValue>(\\n  injectKey: AnyInjectKey<unknown>,\\n  componentKey: string,\\n  defaultValue?: DefaultValue\\n): InjectObjectConfig {\\n  return { [componentKey]: { from: injectKey as string, default: { value: defaultValue } } };\\n}\\n\\n/**\\n * This function returns the computed configuration for bypass the `value` of the provide\\n * of {@link XProvide}. This will be used to override the property decorated with {@link XInject}\\n * with the computed.\\n *\\n * @param computedKey - The key used for the computed.\\n * @param privateComponentKey - The \\\"private\\\" component property where the value is actually\\n * injected.\\n *\\n * @returns The computed config to assign/merge with the component options.\\n */\\nfunction getComputedProperty(\\n  computedKey: string,\\n  privateComponentKey: string\\n): ComponentOptions<Vue>['computed'] {\\n  return {\\n    [computedKey]: function (): unknown {\\n      return (this as unknown as Record<string, { value: unknown }>)[privateComponentKey].value;\\n    }\\n  };\\n}\\n\\n/**\\n * Type guard to check if a provide configuration is a function.\\n *\\n * @param provide - The provide configuration.\\n * @returns A boolean indicating if the passed provide is a function.\\n */\\nfunction isProvideFunction(\\n  provide: ComponentOptions<Vue>['provide']\\n): provide is (this: Vue) => ProvideObjectConfig {\\n  return typeof provide === 'function';\\n}\\n\"],\"names\":[],\"mappings\":\";;;AAwCA;;;;;;;;;;;;;;;;;;;;;;;;;;SA0BgB,QAAQ,CAAO,UAA8B;IAC3D,OAAO,eAAe,CAAC,UAAC,OAAO,EAAE,YAAY;QAC3C,IAAM,eAAe,GAAG,OAAO,CAAC,OAAO,CAAC;QACxC,OAAO,CAAC,OAAO,GAAG;YAChB,IAAM,qBAAqB,GAAG,wBAAwB,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC;YAC9E,IAAM,gBAAgB,GAAG,mBAAmB,CAAC,UAAU,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;YAC7E,OAAO,MAAM,CAAC,MAAM,CAAC,qBAAqB,EAAE,gBAAgB,CAAC,CAAC;SAC/D,CAAC;KACH,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SAkCgB,OAAO,CACrB,SAA6B,EAC7B,YAAmB;IAEnB,OAAO,eAAe,CAAC,UAAC,OAAO,EAAE,YAAY;;QAC3C,IAAM,mBAAmB,GAAG,eAAa,YAAc,CAAC;QACxD,IAAM,oBAAoB,GAAG,uBAAuB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QACrE,IAAM,eAAe,GAAG,kBAAkB,CAAC,SAAS,EAAE,mBAAmB,EAAE,YAAY,CAAC,CAAC;QACzF,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,oBAAoB,EAAE,eAAe,CAAC,CAAC;QACtE,IAAM,yBAAyB,GAAG,mBAAmB,CAAC,YAAY,EAAE,mBAAmB,CAAC,CAAC;QACzF,OAAO,CAAC,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,MAAA,OAAO,CAAC,QAAQ,mCAAI,EAAE,EAAE,yBAAyB,CAAC,CAAC;KACrF,CAAC,CAAC;AACL,CAAC;AAED;;;;;;;;;;;;;AAaA,SAAS,wBAAwB,CAC/B,eAAiD,EACjD,iBAAoC;IAEpC,IAAI,iBAAiB,CAAC,eAAe,CAAC,EAAE;QACtC,OAAO,eAAe,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;KAChD;SAAM;QACL,OAAO,eAAe,aAAf,eAAe,cAAf,eAAe,GAAI,EAAE,CAAC;KAC9B;AACH,CAAC;AAED;;;;;;;;;;;;AAYA,SAAS,mBAAmB,CAC1B,UAAiC,EACjC,YAAoB,EACpB,iBAAoC;;IAEpC;QACE,GAAC,UAAoB,IAAG;YACtB,IAAI,KAAK;gBACP,OAAO,iBAAiB,CAAC,YAAuC,CAAC,CAAC;aACnE;SACF;WACD;AACJ,CAAC;AAED;;;;;;;;;;;;;;AAcA,SAAS,uBAAuB,CAC9B,cAA+C;IAE/C,IAAI,KAAK,CAAC,OAAO,CAAC,cAAc,CAAC,EAAE;QACjC,OAAO,aAAa,CAAC,cAAc,CAAC,CAAC;KACtC;SAAM;QACL,OAAO,cAAc,aAAd,cAAc,cAAd,cAAc,GAAI,EAAE,CAAC;KAC7B;AACH,CAAC;AAED;;;;;;;;;;;;AAYA,SAAS,kBAAkB,CACzB,SAAgC,EAChC,YAAoB,EACpB,YAA2B;;IAE3B,gBAAS,GAAC,YAAY,IAAG,EAAE,IAAI,EAAE,SAAmB,EAAE,OAAO,EAAE,EAAE,KAAK,EAAE,YAAY,EAAE,EAAE,KAAG;AAC7F,CAAC;AAED;;;;;;;;;;;AAWA,SAAS,mBAAmB,CAC1B,WAAmB,EACnB,mBAA2B;;IAE3B;QACE,GAAC,WAAW,IAAG;YACb,OAAQ,IAAsD,CAAC,mBAAmB,CAAC,CAAC,KAAK,CAAC;SAC3F;WACD;AACJ,CAAC;AAED;;;;;;AAMA,SAAS,iBAAiB,CACxB,OAAyC;IAEzC,OAAO,OAAO,OAAO,KAAK,UAAU,CAAC;AACvC;;;;\"}")}}]);