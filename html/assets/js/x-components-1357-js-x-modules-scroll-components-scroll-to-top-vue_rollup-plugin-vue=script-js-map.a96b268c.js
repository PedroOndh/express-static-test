(window.webpackJsonp=window.webpackJsonp||[]).push([[660],{1436:function(A,n){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"scroll-to-top.vue_rollup-plugin-vue=script.js\",\"sources\":[\"../../../../../src/x-modules/scroll/components/scroll-to-top.vue?rollup-plugin-vue=script.ts\"],\"sourcesContent\":[\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nimport Vue from 'vue';\\nimport { Component, Prop } from 'vue-property-decorator';\\nimport { State, xComponentMixin } from '../../../components';\\nimport BaseEventButton from '../../../components/base-event-button.vue';\\nimport { NoElement } from '../../../components/no-element';\\nimport { Dictionary } from '../../../utils';\\nimport { XEventsTypes } from '../../../wiring';\\nimport { ScrollComponentState } from '../store';\\nimport { scrollXModule } from '../x-module';\\nimport { MainScrollId } from './scroll.const';\\n\\n/**\\n * The `ScrollToTop` component is a button that the user can click to make a container scroll\\n * up to its initial position.\\n *\\n * @public\\n */\\n@Component({\\n  mixins: [xComponentMixin(scrollXModule)],\\n  components: { BaseEventButton }\\n})\\nexport default class ScrollToTop extends Vue {\\n  /**\\n   * Animation to use for showing/hiding the button.\\n   *\\n   * @public\\n   */\\n  @Prop({ default: () => NoElement })\\n  public animation!: Vue | string;\\n\\n  /**\\n   * Threshold in pixels from the top to show the button.\\n   *\\n   * @public\\n   */\\n  @Prop()\\n  public thresholdPx?: number;\\n\\n  /**\\n   * Id of the target scroll component.\\n   *\\n   * @public\\n   */\\n  @Prop({ default: MainScrollId })\\n  public scrollId!: string;\\n\\n  /**\\n   * State of all the scroll components in this module.\\n   *\\n   * @internal\\n   */\\n  // TODO: Directly retrieve the needed data in this computed property\\n  @State('scroll', 'data')\\n  public scrollPositionsMap!: Dictionary<ScrollComponentState>;\\n\\n  /**\\n   * The scroll data retrieved for this component.\\n   *\\n   * @returns The scroll data for this component if a valid {@link ScrollToTop.scrollId} has been\\n   * passed. Otherwise it returns `null`.\\n   * @internal\\n   */\\n  protected get scrollData(): ScrollComponentState {\\n    return this.scrollId && this.scrollPositionsMap[this.scrollId]\\n      ? this.scrollPositionsMap[this.scrollId]\\n      : {\\n          position: 0,\\n          direction: 'UP',\\n          hasReachedStart: false,\\n          hasAlmostReachedEnd: false,\\n          hasReachedEnd: false\\n        };\\n  }\\n\\n  /**\\n   * Event that will be emitted when the scroll to top is clicked.\\n   *\\n   * @returns The event to be emitted when the scroll to top is clicked. The id as a payload.\\n   * @internal\\n   */\\n  protected get events(): Partial<XEventsTypes> {\\n    return { UserClickedScrollToTop: this.scrollId };\\n  }\\n\\n  /**\\n   * Checks if the thresholdPx prop has been provided and if it is a number.\\n   *\\n   * @returns If the thresholdPx is a number or not.\\n   * @internal\\n   */\\n  protected get useThresholdStrategy(): boolean {\\n    return typeof this.thresholdPx === 'number';\\n  }\\n\\n  /**\\n   * Checks if the threshold has been reached in case the threshold strategy is in use.\\n   *\\n   * @returns If the scrollTop is bigger than the thresholdPx.\\n   * @internal\\n   */\\n  protected get isThresholdReached(): boolean {\\n    return this.useThresholdStrategy && this.scrollData.position > this.thresholdPx!;\\n  }\\n\\n  /**\\n   * Whether if the button is visible or not depending on the strategy being used.\\n   *\\n   * @returns If the button should be visible or not.\\n   * @internal\\n   */\\n  protected get isVisible(): boolean {\\n    return this.useThresholdStrategy ? this.isThresholdReached : this.hasAlmostReachedScrollEnd;\\n  }\\n\\n  /**\\n   * Returns if the scroll has almost reached its end or not.\\n   *\\n   * @returns True if the scroll has almost reached the end and the user is still scrolling down.\\n   * @internal\\n   */\\n  protected get hasAlmostReachedScrollEnd(): boolean {\\n    return this.scrollData.hasAlmostReachedEnd && this.scrollData.direction === 'DOWN';\\n  }\\n}\\n\"],\"names\":[],\"mappings\":\";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;;;;;AAUA;IAAyC,+BAAG;IAA5C;;KAsGC;IA7DC,sBAAc,mCAAU;;;;;;;;aAAxB;YACE,OAAO,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC;kBAC1D,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,QAAQ,CAAC;kBACtC;oBACE,QAAQ,EAAE,CAAC;oBACX,SAAS,EAAE,IAAI;oBACf,eAAe,EAAE,KAAK;oBACtB,mBAAmB,EAAE,KAAK;oBAC1B,aAAa,EAAE,KAAK;iBACrB,CAAC;SACP;;;OAAA;IAQD,sBAAc,+BAAM;;;;;;;aAApB;YACE,OAAO,EAAE,sBAAsB,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC;SAClD;;;OAAA;IAQD,sBAAc,6CAAoB;;;;;;;aAAlC;YACE,OAAO,OAAO,IAAI,CAAC,WAAW,KAAK,QAAQ,CAAC;SAC7C;;;OAAA;IAQD,sBAAc,2CAAkB;;;;;;;aAAhC;YACE,OAAO,IAAI,CAAC,oBAAoB,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,GAAG,IAAI,CAAC,WAAY,CAAC;SAClF;;;OAAA;IAQD,sBAAc,kCAAS;;;;;;;aAAvB;YACE,OAAO,IAAI,CAAC,oBAAoB,GAAG,IAAI,CAAC,kBAAkB,GAAG,IAAI,CAAC,yBAAyB,CAAC;SAC7F;;;OAAA;IAQD,sBAAc,kDAAyB;;;;;;;aAAvC;YACE,OAAO,IAAI,CAAC,UAAU,CAAC,mBAAmB,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,KAAK,MAAM,CAAC;SACpF;;;OAAA;IA9FD;QADC,IAAI,CAAC,EAAE,OAAO,EAAE,cAAM,OAAA,SAAS,GAAA,EAAE,CAAC;kDACH;IAQhC;QADC,IAAI,EAAE;oDACqB;IAQ5B;QADC,IAAI,CAAC,EAAE,OAAO,EAAE,YAAY,EAAE,CAAC;iDACP;IASzB;QADC,KAAK,CAAC,QAAQ,EAAE,MAAM,CAAC;2DACqC;IAhC1C,WAAW;QAJ/B,SAAS,CAAC;YACT,MAAM,EAAE,CAAC,eAAe,CAAC,aAAa,CAAC,CAAC;YACxC,UAAU,EAAE,EAAE,eAAe,iBAAA,EAAE;SAChC,CAAC;OACmB,WAAW,CAsG/B;IAAD,kBAAC;CAAA,CAtGwC,GAAG;;;;\"}")}}]);