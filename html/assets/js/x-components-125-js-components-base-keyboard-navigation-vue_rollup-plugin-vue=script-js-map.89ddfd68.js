(window.webpackJsonp=window.webpackJsonp||[]).push([[621],{1026:function(A,e){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"base-keyboard-navigation.vue_rollup-plugin-vue=script.js\",\"sources\":[\"../../../src/components/base-keyboard-navigation.vue?rollup-plugin-vue=script.ts\"],\"sourcesContent\":[\"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nimport Vue from 'vue';\\nimport { Component, Prop } from 'vue-property-decorator';\\n// eslint-disable-next-line max-len\\nimport { DirectionalFocusNavigationService } from '../services/directional-focus-navigation.service';\\nimport { SpatialNavigation } from '../services/services.types';\\nimport { ArrowKey, EventsForDirectionLimit, TakeNavigationControl } from '../utils/types';\\nimport { XEventsOf } from '../wiring/events.types';\\nimport { WireMetadata } from '../wiring/wiring.types';\\nimport { XOn } from './decorators/bus.decorators';\\n\\n/**\\n * Base component to handle keyboard navigation for elements inside it. It has a required slot to\\n * include the navigable elements.\\n *\\n * @remarks\\n * The component can be customized through props: an array of navigationHijacker objects, which\\n * contains: the xEvent to listen to, the moduleName in charge of emitting the event and to which\\n * direction it should react to; to take control of the navigation and eventsForDirectionLimit, to\\n * emit an xEvent when reaching the navigation limit in any direction.\\n *\\n * @public\\n */\\n@Component\\nexport default class BaseKeyboardNavigation extends Vue {\\n  /**\\n   * An array of {@link TakeNavigationControl | navigation hijacker} objects defining when to\\n   * take control of the keyboard navigation.\\n   */\\n  @Prop({\\n    default: () => [\\n      { xEvent: 'UserPressedArrowKey', moduleName: 'searchBox', direction: 'ArrowDown' }\\n    ]\\n  })\\n  protected navigationHijacker!: TakeNavigationControl[];\\n\\n  /**\\n   * An {@link EventsForDirectionLimit} to emit when the user is already at the furthest element\\n   * in a direction and tries to keep going on the same direction.\\n   */\\n  @Prop({ default: () => ({ ArrowUp: 'UserReachedEmpathizeTop' }) })\\n  protected eventsForDirectionLimit!: Partial<EventsForDirectionLimit>;\\n\\n  /**\\n   * The {@link SpatialNavigation | navigation service} to use.\\n   */\\n  protected navigationService!: SpatialNavigation;\\n\\n  /**\\n   * The element to focus.\\n   */\\n  protected elementToFocus: HTMLElement | undefined;\\n\\n  mounted(): void {\\n    // TODO Replace this with injection\\n    this.navigationService = new DirectionalFocusNavigationService(this.$el as HTMLElement);\\n  }\\n\\n  /**\\n   * Get the navigation hijacker events.\\n   *\\n   * @remarks\\n   * If the same {@link XEvent} is defined multiple times it is only inserted once.\\n   *\\n   * @returns The events to hijack the navigation.\\n   */\\n  protected get navigationHijackerEvents(): XEventsOf<ArrowKey>[] {\\n    const eventsSet = this.navigationHijacker.map(({ xEvent }) => xEvent);\\n    return Array.from(new Set(eventsSet));\\n  }\\n\\n  /**\\n   * Trigger navigation if this component is in control of it.\\n   *\\n   * @param eventPayload - The {@link WirePayload.eventPayload}.\\n   * @param metadata - The {@link WirePayload.metadata}.\\n   * @public\\n   */\\n  @XOn(component => (component as BaseKeyboardNavigation).navigationHijackerEvents)\\n  triggerNavigation(eventPayload: ArrowKey, metadata: WireMetadata): void {\\n    if (this.hasToTakeNavigationControl(eventPayload, metadata)) {\\n      this.focusNextNavigableElement(eventPayload);\\n    }\\n  }\\n\\n  /**\\n   * Checks if the component has to take control of the keyboard navigation.\\n   *\\n   * @param eventPayload - The {@link ArrowKey}.\\n   * @param metadata - The {@link WireMetadata}.\\n   *\\n   * @returns Whether the component needs to take control of the keyboard navigation or not.\\n   * @internal\\n   */\\n  private hasToTakeNavigationControl(eventPayload: ArrowKey, metadata: WireMetadata): boolean {\\n    return this.navigationHijacker.some(\\n      ({ moduleName, direction }) =>\\n        moduleName === metadata.moduleName && direction === eventPayload\\n    );\\n  }\\n\\n  /**\\n   * Focus the next navigable element returned by the navigation service.\\n   *\\n   * @param direction - The navigation direction.\\n   * @internal\\n   */\\n  protected focusNextNavigableElement(direction: ArrowKey | KeyboardEvent): void {\\n    const dir = typeof direction === 'object' ? (direction.key as ArrowKey) : direction;\\n    const nextElementToFocus = this.navigationService?.navigateTo(dir);\\n\\n    if (this.elementToFocus !== nextElementToFocus) {\\n      this.elementToFocus = nextElementToFocus;\\n      this.elementToFocus.focus();\\n    } else {\\n      this.emitDirectionalLimitReached(dir);\\n      this.elementToFocus = undefined;\\n    }\\n  }\\n\\n  /**\\n   * Emit the {@link XEvent} associated to the navigation's direction when reaching its limit.\\n   *\\n   * @param direction - The navigation direction.\\n   * @internal\\n   */\\n  private emitDirectionalLimitReached(direction: ArrowKey): void {\\n    const xEvent = this.eventsForDirectionLimit?.[direction];\\n    if (xEvent) {\\n      this.$x.emit(xEvent, undefined, { target: this.elementToFocus });\\n    }\\n  }\\n}\\n\"],\"names\":[],\"mappings\":\";;;;;;AAsBA;;;;;;;;;;;;AAaA;IAAoD,0CAAG;IAAvD;;KA4GC;IA/EC,wCAAO,GAAP;;QAEE,IAAI,CAAC,iBAAiB,GAAG,IAAI,iCAAiC,CAAC,IAAI,CAAC,GAAkB,CAAC,CAAC;KACzF;IAUD,sBAAc,4DAAwB;;;;;;;;;aAAtC;YACE,IAAM,SAAS,GAAG,IAAI,CAAC,kBAAkB,CAAC,GAAG,CAAC,UAAC,EAAU;oBAAR,MAAM,YAAA;gBAAO,OAAA,MAAM;aAAA,CAAC,CAAC;YACtE,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC;SACvC;;;OAAA;;;;;;;;IAUD,kDAAiB,GAAjB,UAAkB,YAAsB,EAAE,QAAsB;QAC9D,IAAI,IAAI,CAAC,0BAA0B,CAAC,YAAY,EAAE,QAAQ,CAAC,EAAE;YAC3D,IAAI,CAAC,yBAAyB,CAAC,YAAY,CAAC,CAAC;SAC9C;KACF;;;;;;;;;;IAWO,2DAA0B,GAAlC,UAAmC,YAAsB,EAAE,QAAsB;QAC/E,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI,CACjC,UAAC,EAAyB;gBAAvB,UAAU,gBAAA,EAAE,SAAS,eAAA;YACtB,OAAA,UAAU,KAAK,QAAQ,CAAC,UAAU,IAAI,SAAS,KAAK,YAAY;SAAA,CACnE,CAAC;KACH;;;;;;;IAQS,0DAAyB,GAAnC,UAAoC,SAAmC;;QACrE,IAAM,GAAG,GAAG,OAAO,SAAS,KAAK,QAAQ,GAAI,SAAS,CAAC,GAAgB,GAAG,SAAS,CAAC;QACpF,IAAM,kBAAkB,GAAG,MAAA,IAAI,CAAC,iBAAiB,0CAAE,UAAU,CAAC,GAAG,CAAC,CAAC;QAEnE,IAAI,IAAI,CAAC,cAAc,KAAK,kBAAkB,EAAE;YAC9C,IAAI,CAAC,cAAc,GAAG,kBAAkB,CAAC;YACzC,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;SAC7B;aAAM;YACL,IAAI,CAAC,2BAA2B,CAAC,GAAG,CAAC,CAAC;YACtC,IAAI,CAAC,cAAc,GAAG,SAAS,CAAC;SACjC;KACF;;;;;;;IAQO,4DAA2B,GAAnC,UAAoC,SAAmB;;QACrD,IAAM,MAAM,GAAG,MAAA,IAAI,CAAC,uBAAuB,0CAAG,SAAS,CAAC,CAAC;QACzD,IAAI,MAAM,EAAE;YACV,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,MAAM,EAAE,IAAI,CAAC,cAAc,EAAE,CAAC,CAAC;SAClE;KACF;IAjGD;QALC,IAAI,CAAC;YACJ,OAAO,EAAE,cAAM,OAAA;gBACb,EAAE,MAAM,EAAE,qBAAqB,EAAE,UAAU,EAAE,WAAW,EAAE,SAAS,EAAE,WAAW,EAAE;aACnF,GAAA;SACF,CAAC;sEACqD;IAOvD;QADC,IAAI,CAAC,EAAE,OAAO,EAAE,cAAM,QAAC,EAAE,OAAO,EAAE,yBAAyB,EAAE,IAAC,EAAE,CAAC;2EACG;IAsCrE;QADC,GAAG,CAAC,UAAA,SAAS,IAAI,OAAC,SAAoC,CAAC,wBAAwB,GAAA,CAAC;mEAKhF;IA3DkB,sBAAsB;QAD1C,SAAS;OACW,sBAAsB,CA4G1C;IAAD,6BAAC;CAAA,CA5GmD,GAAG;;;;\"}")}}]);