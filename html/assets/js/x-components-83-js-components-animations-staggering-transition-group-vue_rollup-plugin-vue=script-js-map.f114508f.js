(window.webpackJsonp=window.webpackJsonp||[]).push([[990],{1012:function(A,n){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"staggering-transition-group.vue_rollup-plugin-vue=script.js\",\"sources\":[\"../../../../src/components/animations/staggering-transition-group.vue?rollup-plugin-vue=script.ts\"],\"sourcesContent\":[\"\\nimport Vue, { CreateElement, VNode } from 'vue';\\nimport { Component, Prop } from 'vue-property-decorator';\\nimport { noOp } from '../../utils';\\n\\n/* eslint-disable @typescript-eslint/unbound-method */\\n/**\\n * A replacement component for Vue's transition-group, that also adds the option to stagger\\n * the animations.\\n *\\n * @public\\n */\\n@Component\\nexport default class StaggeringTransitionGroup extends Vue {\\n  /**\\n   * The name of the transition. Used to generate the CSS classes.\\n   *\\n   * @internal\\n   */\\n  @Prop({ default: 'v' })\\n  public name!: string;\\n\\n  /** The CSS move class name.\\n   *\\n   * @internal\\n   */\\n  @Prop()\\n  public moveClass!: string;\\n\\n  /**\\n   * The tag of the node to render to the DOM.\\n   *\\n   * @internal\\n   */\\n  @Prop({ default: 'div' })\\n  public tag!: string;\\n\\n  /**\\n   * The time in ms to stagger each item.\\n   *\\n   * @internal\\n   */\\n  @Prop({ default: 25 })\\n  public staggering!: number;\\n\\n  /**\\n   * The CSS class for the moving transitions.\\n   *\\n   * @returns The move transition name.\\n   * @internal\\n   */\\n  protected get moveClassName(): string {\\n    return this.moveClass ?? `${this.name}-move`;\\n  }\\n\\n  /**\\n   * The transition data contains the needed events and props to perform a transition using Vue\\n   * virtual node's API.\\n   *\\n   * The `beforeLeave` hook is extended to also restore the previous position of the element using\\n   * the position absolute.\\n   * The `afterEnter` and `afterLeave` hooks are extended to also clean the transition delay\\n   * applied by the stagger.\\n   *\\n   * @returns The transition data for Vue virtual nodes.\\n   * @internal\\n   */\\n  protected get transitionData(): TransitionData {\\n    const transitionData: TransitionData = { ...this.$props, ...this.$attrs, ...this.$listeners };\\n\\n    transitionData.beforeLeave = this.addRestorePositionHook(transitionData.beforeLeave);\\n    transitionData.afterEnter = this.addClearStaggeringCall(transitionData.afterEnter);\\n    transitionData.afterLeave = this.addClearStaggeringCall(transitionData.afterLeave);\\n\\n    return transitionData;\\n  }\\n\\n  /** The list of old virtual nodes, generated by the previous called render method.\\n   *\\n   * @internal */\\n  protected oldChildren!: TransitionVNode[];\\n  /** The list of new virtual nodes, generated by the last called render method.\\n   *\\n   * @internal */\\n  protected newChildren!: TransitionVNode[];\\n  /** A map containing the previous positions relative to the container, for each item\\n   * rendered inside the slot of this component component.\\n   * This is used together with the `newPositions` to calculate the move transition.\\n   *\\n   * @internal */\\n  protected oldPositions!: WeakMap<Element, Bounds>;\\n  /** A map containing the new positions relative to the container, for each item\\n   * rendered inside the slot of this component component.\\n   * This is used together with the `newPositions` to calculate the move transition.\\n   *\\n   * @internal */\\n  protected newPositions!: WeakMap<Element, Bounds>;\\n  /** A map containing the move cleanup functions pending to have been called. When invoked\\n   * this functions remove all the styles and classes associated to the move transition.\\n   *\\n   * @internal */\\n  protected pendingCleanupMoveCallbacks!: WeakMap<Element, () => void>;\\n  /** The counter for the stagger, used to calculate the delay for the transition of each child\\n   * element. It is reset every time the render method is triggered.\\n   *\\n   * @internal */\\n  protected staggerCounter!: number;\\n  /** The bounds of the container rendered using the `tag` prop. This is used to calculate the\\n   * relative positions of each leaving child, which are then applied with the position absolute.\\n   *\\n   * @internal */\\n  protected wrapperBounds!: DOMRect;\\n\\n  beforeCreate(): void {\\n    /* Initialize properties here to avoid making them reactive,\\n   which would cause infinite loops */\\n    this.oldChildren = [];\\n    this.newChildren = [];\\n    this.oldPositions = new WeakMap();\\n    this.newPositions = new WeakMap();\\n    this.pendingCleanupMoveCallbacks = new WeakMap<Element, () => void>();\\n    this.staggerCounter = 0;\\n  }\\n\\n  render(createElement: CreateElement): VNode {\\n    this.staggerCounter = 0;\\n    // New children are now the old ones\\n    this.oldChildren = this.newChildren;\\n    // Only vnodes with a tag (i.e. no HTML comments) and with a `key` property are valid.\\n    this.newChildren = (this.$slots.default ?? []).filter(this.isTransitionValidVNode);\\n\\n    // Apply transition data to both new and old nodes & store the position of the old nodes.\\n    this.newChildren.forEach(this.addTransitionData);\\n    this.oldChildren.forEach(this.syncOldNodes);\\n\\n    return createElement(\\n      this.tag,\\n      { staticClass: 'x-staggering-transition-group' },\\n      this.newChildren\\n    );\\n  }\\n\\n  mounted(): void {\\n    this.newChildren.forEach(this.applyStagger);\\n  }\\n\\n  beforeUpdate(): void {\\n    this.wrapperBounds = this.$el.getBoundingClientRect();\\n  }\\n\\n  updated(): void {\\n    this.wrapperBounds = this.$el.getBoundingClientRect();\\n    this.newChildren.forEach(this.recordNewPosition);\\n    const { leavingNodes, stayingNodes, enteringNodes } = this.getNodesByTransitionType();\\n\\n    leavingNodes.forEach(vNode => {\\n      this.applyStagger(vNode);\\n      this.disableClickingEvents(vNode);\\n    });\\n    const movedChildren = stayingNodes.filter(this.applyTranslation);\\n    const movedStagger = movedChildren.map(this.getNextTransitionDelay);\\n    enteringNodes.forEach(this.applyStagger);\\n\\n    // force reflow to put everything in position\\n    document.body.getBoundingClientRect();\\n\\n    movedChildren.forEach(this.startMoveAnimation(movedStagger));\\n  }\\n\\n  /**\\n   * Extends the provided leave transition hook restoring the position of the element with an\\n   * absolute position.\\n   * Additionally, it removes the element position from the maps of positions.\\n   *\\n   * @param transitionHook - The leave transition hook to extend.\\n   * @returns The new leave transition hook extended.\\n   * @internal\\n   */\\n  protected addRestorePositionHook(transitionHook: TransitionHook = noOp): TransitionHook {\\n    return element => {\\n      const { top, left, width, height } = this.oldPositions.get(element)!;\\n      const { marginTop, marginLeft } = window.getComputedStyle(element);\\n      const style = element.style;\\n      style.position = 'absolute';\\n      style.top = `${top - parseFloat(marginTop)}px`;\\n      style.left = `${left - parseFloat(marginLeft)}px`;\\n      style.width = `${width}px`;\\n      style.height = `${height}px`;\\n      this.newPositions.delete(element);\\n      this.oldPositions.delete(element);\\n      const pendingCallback = this.pendingCleanupMoveCallbacks.get(element);\\n      pendingCallback?.();\\n      transitionHook(element);\\n    };\\n  }\\n\\n  /**\\n   * Extends the provided transition hook clearing the transition delay.\\n   *\\n   * @param transitionHook - The transition hook to extend.\\n   * @returns The new transition hook, that also clears the transitionDelay from the element.\\n   * @internal\\n   */\\n  protected addClearStaggeringCall(transitionHook: TransitionHook = noOp): TransitionHook {\\n    return element => {\\n      element.style.transitionDelay = '';\\n      transitionHook(element);\\n    };\\n  }\\n\\n  /**\\n   * Returns if the vNode contains a non empty key, and a non empty tag.\\n   *\\n   * @param vNode - The VNode to check if it is a valid transition node, containing a `tag` and a\\n   * `key` property.\\n   * @returns True when the vNode contains a non empty key and a non empty tag. False otherwise.\\n   * @internal\\n   */\\n  protected isTransitionValidVNode(vNode: VNode): vNode is TransitionVNode {\\n    // TODO Add warning with logger: <staggering-transition-group> children must be keyed.\\n    return !!vNode.key && !!vNode.tag;\\n  }\\n\\n  /**\\n   * Adds the generated transition data to the vNode, creating the `data` property if necessary.\\n   *\\n   * @param vNode - The VNode to add the transition data to.\\n   * @internal\\n   */\\n  protected addTransitionData(vNode: TransitionVNode): void {\\n    if (!vNode.data) {\\n      vNode.data = {};\\n    }\\n    vNode.data.transition = this.transitionData;\\n  }\\n\\n  /**\\n   * Re-applies the transition data to an old node, just in case it changed from the previous\\n   * render call. It also records the position of the node, to then calculate the move\\n   * transitions.\\n   *\\n   * @param vNode - The vNode to add the transition data to, and record his current position as\\n   * old.\\n   * @internal\\n   */\\n  protected syncOldNodes(vNode: TransitionVNode): void {\\n    // Synchronize transition data, in case it changed in the last frame.\\n    // We can trust data to be defined because each new node has the transition applied\\n    vNode.data!.transition = this.transitionData;\\n    this.recordOldPosition(vNode);\\n  }\\n\\n  /**\\n   * Saves the position of the vNode in the map of old positions.\\n   *\\n   * @param vNode - The node to store its position.\\n   * @internal\\n   */\\n  protected recordOldPosition(vNode: TransitionVNode): void {\\n    this.oldPositions.set(vNode.elm, this.createRelativeBounds(vNode));\\n  }\\n\\n  /**\\n   * Saves the position of the vNode in the map of new positions.\\n   *\\n   * @param vNode - The node to store its position.\\n   * @internal\\n   */\\n  protected recordNewPosition(vNode: TransitionVNode): void {\\n    this.newPositions.set(vNode.elm, this.createRelativeBounds(vNode));\\n  }\\n\\n  /**\\n   * Creates an object containing the position of the vNode relative to its container.\\n   *\\n   * @param vNode - The virtual node to store its relative position.\\n   * @returns The relative bounds of the provided virtual node.\\n   * @internal\\n   */\\n  protected createRelativeBounds(vNode: TransitionVNode): Bounds {\\n    const { left, top, width, height } = vNode.elm.getBoundingClientRect();\\n    const { left: wrapperLeft, top: wrapperTop } = this.wrapperBounds;\\n    return {\\n      left: left - wrapperLeft,\\n      top: top - wrapperTop,\\n      width,\\n      height\\n    };\\n  }\\n\\n  /**\\n   * Splits the children of the component into three groups:\\n   * - Nodes that are leaving.\\n   * - Nodes that are entering.\\n   * - Nodes that stay.\\n   *\\n   * This is then used to apply the stagger in the correct order: leave -\\\\> move -\\\\> enter.\\n   *\\n   * @returns The children nodes, divided in different groups depending on if they are leaving,\\n   * staying or entering.\\n   * @internal\\n   */\\n  protected getNodesByTransitionType(): TransitionTypeNodes {\\n    const leave = this.oldChildren.filter(child => !this.newPositions.has(child.elm));\\n    const enter = this.newChildren.filter(child => !this.oldPositions.has(child.elm));\\n    const stay = this.oldChildren.filter(child => this.newPositions.has(child.elm));\\n    return {\\n      leavingNodes: leave,\\n      enteringNodes: enter,\\n      stayingNodes: stay\\n    };\\n  }\\n\\n  /**\\n   * Applies an incremental delay to the virtual node element.\\n   *\\n   * @param vNode - The virtual node to apply the stagger to.\\n   * @internal\\n   */\\n  protected applyStagger(vNode: TransitionVNode): void {\\n    vNode.elm.style.transitionDelay = this.getNextTransitionDelay();\\n  }\\n\\n  /**\\n   * Disables listening to click events in a virtual node element.\\n   *\\n   * @remarks This is done to avoid letting the user click elements that are performing the moving\\n   * animation to leave the DOM but are still rendered.\\n   *\\n   * @param vNode - The virtual node to disable listening to click events.\\n   * @internal\\n   */\\n  protected disableClickingEvents(vNode: TransitionVNode): void {\\n    vNode.elm.style.pointerEvents = 'none';\\n  }\\n\\n  /**\\n   * Calculates the next transition delay property, incrementing the `staggerCounter` property\\n   * each time it is called.\\n   *\\n   * @returns The value for the next element `style.transitionDelay` property.\\n   * @internal\\n   */\\n  protected getNextTransitionDelay(): string {\\n    return `${this.staggerCounter++ * this.staggering}ms`;\\n  }\\n\\n  /**\\n   * Calculates if the virtual node should have a move transition. If its has it, then it\\n   * applies it immediately using the `style.transform`.\\n   *\\n   * @param vNode - The virtual node to calculate if it should have a move transition.\\n   * @returns True when a move transition was applied to the virtual node.\\n   * @internal\\n   */\\n  protected applyTranslation(vNode: TransitionVNode): boolean {\\n    const oldPosition = this.oldPositions.get(vNode.elm as Element)!;\\n    const newPosition = this.newPositions.get(vNode.elm as Element)!;\\n    const dx = oldPosition.left - newPosition.left;\\n    const dy = oldPosition.top - newPosition.top;\\n    if (dx !== 0 || dy !== 0) {\\n      const style = vNode.elm.style;\\n      style.transform = `translate3d(${dx}px,${dy}px,0)`;\\n      style.transitionDuration = '0s';\\n      return true;\\n    }\\n    return false;\\n  }\\n\\n  /**\\n   * Generates a function to start the moving animations to each node that it needs them with the\\n   * provided stagger.\\n   *\\n   * @param moveStagger - A list containing the delay to add to each node.\\n   * @returns A function that starts the moving animation with the provided stagger to a single\\n   * virtual node.\\n   * @internal\\n   */\\n  protected startMoveAnimation(\\n    moveStagger: string[]\\n  ): (vNode: TransitionVNode, index: number) => void {\\n    return (vNode, index) => {\\n      const element = vNode.elm;\\n      const style = element.style;\\n      element.classList.add(this.moveClassName);\\n      style.transform = style.transitionDuration = '';\\n      style.transitionDelay = moveStagger[index];\\n      const cleanMoveTransition = (event?: TransitionEvent): void => {\\n        if (!event || (event.target === element && /transform$/.test(event.propertyName))) {\\n          element.removeEventListener('transitionend', cleanMoveTransition);\\n          element.style.transitionDelay = '';\\n          element.classList.remove(this.moveClassName);\\n          this.pendingCleanupMoveCallbacks.delete(element);\\n        }\\n      };\\n      this.pendingCleanupMoveCallbacks.set(element, cleanMoveTransition);\\n      element.addEventListener('transitionend', cleanMoveTransition);\\n    };\\n  }\\n}\\n\\n/**\\n * Contains arrays of nodes, splitted by the action they should have.\\n */\\ninterface TransitionTypeNodes {\\n  leavingNodes: TransitionVNode[];\\n  stayingNodes: TransitionVNode[];\\n  enteringNodes: TransitionVNode[];\\n}\\n\\n/**\\n * Safe transition version of the VNode type, with the required non optional properties.\\n */\\ninterface TransitionVNode extends VNode {\\n  elm: HTMLElement;\\n  tag: string;\\n  key: string;\\n}\\n\\n/**\\n * Vue's VNode {@link https://vuejs.org/v2/api/#transition | transition} data props and events.\\n */\\ninterface TransitionData {\\n  name?: string;\\n  appear?: boolean;\\n  css?: boolean;\\n  type?: 'transition' | 'animation'; // Unused\\n  mode?: 'out-in' | 'in-out'; // Unused\\n  duration?: number;\\n  enterClass?: string;\\n  leaveClass?: string;\\n  appearClass?: string;\\n  enterToClass?: string;\\n  leaveToClass?: string;\\n  appearToClass?: string;\\n  enterActiveClass?: string;\\n  leaveActiveClass?: string;\\n  appearActiveClass?: string;\\n  beforeEnter?: TransitionHook;\\n  enter?: TransitionHook;\\n  afterEnter?: TransitionHook;\\n  beforeLeave?: TransitionHook;\\n  leave?: TransitionHook;\\n  afterLeave?: TransitionHook;\\n}\\n\\n/**\\n * A function that receives an HTMLElement. Used to perform actions when the different phases\\n * of Vue transitions happens.\\n */\\ntype TransitionHook = (element: HTMLElement) => void;\\n\\n/**\\n * Represents the dimensions and positions of an element.\\n */\\ninterface Bounds {\\n  top: number;\\n  left: number;\\n  width: number;\\n  height: number;\\n}\\n\"],\"names\":[],\"mappings\":\"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\"}")}}]);