(window.webpackJsonp=window.webpackJsonp||[]).push([[946],{1221:function(A,n){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"directional-focus-navigation.service.js\",\"sources\":[\"../../../src/services/directional-focus-navigation.service.ts\"],\"sourcesContent\":[\"import { ArrowKey } from '../utils/types';\\nimport {\\n  AbsoluteDistances,\\n  Intersection,\\n  Point,\\n  Points,\\n  SpatialNavigation\\n} from './services.types';\\n\\n/**\\n * Implementation of {@link SpatialNavigation} using directional focus.\\n *\\n * @public\\n */\\nexport class DirectionalFocusNavigationService implements SpatialNavigation {\\n  /**\\n   * The HTMLElement that is currently on focus and used as reference to navigateTo from.\\n   */\\n  private origin!: HTMLElement;\\n\\n  /**\\n   * The DOMRect of the origin Element.\\n   */\\n  private originRect!: DOMRect;\\n\\n  /**\\n   * Direction of the navigation.\\n   */\\n  private direction!: ArrowKey;\\n\\n  /**\\n   * Weight of the projected intersection area weight in the\\n   * {@link DirectionalFocusNavigationService.getDistanceScore | getDistanceScore} formula.\\n   */\\n  private readonly intersectionAreaWeight = 100;\\n\\n  /**\\n   * Weight of the absolute distance on the orthogonal axis between to elements when navigating\\n   * left or right. Used to calculate the displacement in\\n   * {@link DirectionalFocusNavigationService.getDisplacementAndAlignment |\\n   * getDisplacementAndAlignment}.\\n   */\\n  private readonly orthogonalWeightHorizontal = 30;\\n\\n  /**\\n   * Weight of the absolute distance on the orthogonal axis between to elements when navigating\\n   * up or down. Used to calculate the displacement in\\n   * {@link DirectionalFocusNavigationService.getDisplacementAndAlignment |\\n   * getDisplacementAndAlignment}.\\n   */\\n  private readonly orthogonalWeightVertical = 2;\\n\\n  /**\\n   * Weight of the degree of alignment between two elements when calculating the alignment in\\n   * {@link DirectionalFocusNavigationService.getDisplacementAndAlignment |\\n   * getDisplacementAndAlignment}.\\n   */\\n  private readonly alignWeight = 5;\\n\\n  /**\\n   * Set of functions to filter out candidates based on the navigation's direction.\\n   */\\n  private readonly filterFunction = {\\n    ArrowUp: (candidateRect: DOMRect) => this.isBelow(this.originRect, candidateRect),\\n    ArrowRight: (candidateRect: DOMRect) => this.isRightSide(candidateRect, this.originRect),\\n    ArrowDown: (candidateRect: DOMRect) => this.isBelow(candidateRect, this.originRect),\\n    ArrowLeft: (candidateRect: DOMRect) => this.isRightSide(this.originRect, candidateRect)\\n  };\\n\\n  /**\\n   * Constructor for the {@link DirectionalFocusNavigationService}.\\n   *\\n   * @param container - The element that contains the navigable elements.\\n   * @param focusableSelectors - A comma separated string with the focusable selectors to look up.\\n   */\\n  public constructor(\\n    /**\\n     * The {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement | HTMLElement} that\\n     * contains the navigable elements.\\n     */\\n    private readonly container: HTMLElement,\\n    /**\\n     * Comma separated focusable selectors to look up.\\n     */\\n    // eslint-disable-next-line max-len\\n    private readonly focusableSelectors: string = 'a, button, details, input, textarea, select, [tabindex]:not([tabindex=\\\"-1\\\"])'\\n  ) {}\\n\\n  /**\\n   * Get the element that would be the next one to be navigated to based on the direction of the\\n   * arrow key pressed. If there are no possible candidates the element to focus would be the one on\\n   * currently on focus or the first one in the container.\\n   *\\n   * @param arrowKey - The arrow key that was pressed.\\n   *\\n   * @returns The element to navigate to.\\n   */\\n  navigateTo(arrowKey: ArrowKey): HTMLElement {\\n    const rawCandidates = this.getFocusableElements();\\n    this.direction = arrowKey;\\n    this.updateOrigin();\\n\\n    return this.getBestCandidate(rawCandidates);\\n  }\\n\\n  /**\\n   * Gets focusable elements within the container.\\n   *\\n   * @returns List of focusable elements.\\n   * @internal\\n   */\\n  private getFocusableElements(): HTMLElement[] {\\n    return Array.from(this.container.querySelectorAll(this.focusableSelectors));\\n  }\\n\\n  /**\\n   * Updates the origin with the current document active element.\\n   *\\n   * @remarks\\n   * This also covers cases when the user might have iterated through the DOM using the TAB or\\n   * SHIFT+TAB keys.\\n   */\\n  private updateOrigin(): void {\\n    const newOrigin = document.activeElement as HTMLElement;\\n    this.origin = newOrigin;\\n    this.originRect = newOrigin.getBoundingClientRect();\\n  }\\n\\n  /**\\n   * Finds the closest candidate to the origin from a list of candidates.\\n   *\\n   * @remarks\\n   * If there are no candidates the origin will be retrieved as best candidate.\\n   *\\n   * @param rawCandidates - List of all candidates.\\n   *\\n   * @returns The closest candidate to the origin or origin if there's none.\\n   * @internal\\n   */\\n  private getBestCandidate(rawCandidates: HTMLElement[]): HTMLElement {\\n    const candidates = this.filterCandidates(rawCandidates);\\n    let bestCandidate = this.origin;\\n\\n    candidates.reduce((bestCurrentScore: number, candidate) => {\\n      const bestScore = Math.min(bestCurrentScore, this.getDistanceScore(candidate));\\n      if (bestScore !== bestCurrentScore) {\\n        bestCandidate = candidate;\\n      }\\n      return bestScore;\\n    }, Number.MAX_SAFE_INTEGER);\\n\\n    return bestCandidate;\\n  }\\n\\n  /**\\n   * Filters out candidates that can't be candidates based on the direction of the navigation and\\n   * if they are visible and enabled.\\n   *\\n   * @param rawCandidates - List of all candidates.\\n   *\\n   * @returns List of filtered candidates.\\n   * @internal\\n   */\\n  private filterCandidates(rawCandidates: HTMLElement[]): HTMLElement[] {\\n    return rawCandidates.filter(candidate => this.isValidCandidate(candidate));\\n  }\\n\\n  /**\\n   * Checks if the provided candidate is not the origin, is visible, enabled  and in the correct\\n   * direction to be a valid candidate.\\n   *\\n   * @param candidate - The candidate element.\\n   * @returns If the candidate is valid for the navigation.\\n   * @internal\\n   */\\n  private isValidCandidate(candidate: HTMLElement): boolean {\\n    return (\\n      candidate !== this.origin &&\\n      this.isCandidateVisible(candidate) &&\\n      this.hasFocusCompatibleAttributes(candidate) &&\\n      this.isInNavigateDirection(candidate)\\n    );\\n  }\\n\\n  /**\\n   * Checks if the provided candidate is visible.\\n   *\\n   * @param candidate - The candidate element.\\n   * @returns If the candidate is visible.\\n   * @internal\\n   */\\n  private isCandidateVisible(candidate: HTMLElement): boolean {\\n    const candidateStyle = window.getComputedStyle(candidate, null);\\n\\n    return !!(\\n      candidate.offsetWidth &&\\n      candidate.offsetHeight &&\\n      candidateStyle.visibility === 'visible'\\n    );\\n  }\\n\\n  /**\\n   * Checks if the provided candidate is disabled and if the tabindex allows the element to be\\n   * focused.\\n   *\\n   * @param candidate - The candidate element.\\n   * @returns If candidate's attributes allow it to be focused.\\n   * @internal\\n   */\\n  private hasFocusCompatibleAttributes(candidate: HTMLElement): boolean {\\n    return !candidate.getAttribute('disabled') && candidate.getAttribute('tabindex') !== '-1';\\n  }\\n\\n  /**\\n   * Checks if the provided candidate is in the direction the navigation is going.\\n   *\\n   * @param candidate - The candidate element.\\n   * @returns If the candidate is in the correct direction.\\n   * @internal\\n   */\\n  private isInNavigateDirection(candidate: HTMLElement): boolean {\\n    return this.filterFunction[this.direction](candidate.getBoundingClientRect());\\n  }\\n\\n  /**\\n   * Calculates the candidate's score for it to be the next element to navigateTo to based on a\\n   * formula that takes into account euclidean distance, displacement, alignment and\\n   * intersection area relative to the origin element.\\n   *\\n   * @param candidate - The candidate element.\\n   *\\n   * @returns The candidate score for best candidate.\\n   * @internal\\n   */\\n  private getDistanceScore(candidate: HTMLElement): number {\\n    const candidateRect = candidate.getBoundingClientRect();\\n    const { 0: candidatePoint, 1: originPoint } = this.getComparisionPoints(candidateRect);\\n    const absoluteDistances: AbsoluteDistances = {\\n      x: Math.abs(candidatePoint.x - originPoint.x),\\n      y: Math.abs(candidatePoint.y - originPoint.y)\\n    };\\n    const euclideanDistance = Math.sqrt(\\n      Math.pow(absoluteDistances.x, 2) + Math.pow(absoluteDistances.y, 2)\\n    );\\n    const intersection = this.getIntersection(this.originRect, candidateRect);\\n    const { displacement, alignment } = this.getDisplacementAndAlignment(\\n      candidateRect,\\n      intersection,\\n      absoluteDistances\\n    );\\n    const projectedArea = Math.sqrt(intersection.area) / this.intersectionAreaWeight;\\n\\n    return euclideanDistance + displacement - alignment - projectedArea;\\n  }\\n\\n  /**\\n   * Gets the closest point to origin within the candidate and to the candidate within the origin\\n   * based on the navigation direction.\\n   *\\n   * @param candidateRect - The DOMRect of the candidate.\\n   *\\n   * @returns The candidate's closest Points to the origin.\\n   * @internal\\n   */\\n  private getComparisionPoints(candidateRect: DOMRect): Points {\\n    const points: Points = [\\n      { x: 0, y: 0 },\\n      { x: 0, y: 0 }\\n    ];\\n\\n    return {\\n      ...this.setParallelPointValues(points, candidateRect),\\n      ...this.setOrthogonalPointValues(points, candidateRect)\\n    };\\n  }\\n\\n  /**\\n   * Set parallel values between candidate and origin based on the navigation direction and\\n   * returns them.\\n   *\\n   * @param points - Current values for the candidate and origin's points.\\n   * @param candidateRect - The DOMRect of the candidate.\\n   *\\n   * @returns Candidate and origin points with parallel values set.\\n   * @internal\\n   */\\n  private setParallelPointValues(\\n    { 0: candidatePoint, 1: originPoint }: Points,\\n    candidateRect: DOMRect\\n  ): Points {\\n    switch (this.direction) {\\n      case 'ArrowUp':\\n        candidatePoint.y = Math.min(candidateRect.bottom, this.originRect.top);\\n        originPoint.y = this.originRect.top;\\n        break;\\n      case 'ArrowDown':\\n        candidatePoint.y = Math.max(candidateRect.top, this.originRect.bottom);\\n        originPoint.y = this.originRect.bottom;\\n        break;\\n      case 'ArrowRight':\\n        candidatePoint.x = Math.max(candidateRect.left, this.originRect.right);\\n        originPoint.x = this.originRect.right;\\n        break;\\n      case 'ArrowLeft':\\n        candidatePoint.x = Math.min(candidateRect.right, this.originRect.left);\\n        originPoint.x = this.originRect.left;\\n        break;\\n    }\\n\\n    return [candidatePoint, originPoint];\\n  }\\n\\n  /**\\n   * Set orthogonal values between candidate and origin based on the navigation direction and\\n   * returns them.\\n   *\\n   * @param points - Current values for the candidate and origin's points.\\n   * @param candidateRect - The DOMRect of the candidate.\\n   *\\n   * @returns Candidate and origin points with orthogonal values set.\\n   * @internal\\n   */\\n  private setOrthogonalPointValues(\\n    { 0: candidatePoint, 1: originPoint }: Points,\\n    candidateRect: DOMRect\\n  ): Points {\\n    switch (this.direction) {\\n      case 'ArrowUp':\\n      case 'ArrowDown':\\n        if (this.isRightSide(this.originRect, candidateRect)) {\\n          candidatePoint.x = Math.min(candidateRect.right, this.originRect.left);\\n          originPoint.x = this.originRect.left;\\n        } else if (this.isRightSide(candidateRect, this.originRect)) {\\n          candidatePoint.x = Math.max(candidateRect.left, this.originRect.right);\\n          originPoint.x = this.originRect.right;\\n        } else {\\n          candidatePoint.x = Math.max(this.originRect.left, candidateRect.left);\\n          originPoint.x = candidatePoint.x;\\n        }\\n        break;\\n\\n      case 'ArrowRight':\\n      case 'ArrowLeft':\\n        if (this.isBelow(this.originRect, candidateRect)) {\\n          candidatePoint.y = Math.min(candidateRect.bottom, this.originRect.top);\\n          originPoint.y = this.originRect.top;\\n        } else if (this.isBelow(candidateRect, this.originRect)) {\\n          candidatePoint.y = Math.max(candidateRect.top, this.originRect.bottom);\\n          originPoint.y = this.originRect.bottom;\\n        } else {\\n          candidatePoint.y = Math.max(this.originRect.top, candidateRect.top);\\n          originPoint.y = candidatePoint.y;\\n        }\\n        break;\\n    }\\n\\n    return [candidatePoint, originPoint];\\n  }\\n\\n  /**\\n   * Calculates the displacement and alignment values for the candidate relative to the origin.\\n   *\\n   * @param candidateRect - The DOMRect of the candidate.\\n   * @param intersection - Projected intersection between candidate and origin.\\n   * @param absoluteDistances - Absolute distances between candidate and origin points.\\n   *\\n   * @returns Displacement and alignment values.\\n   * @internal\\n   */\\n  private getDisplacementAndAlignment(\\n    candidateRect: DOMRect,\\n    intersection: Intersection,\\n    absoluteDistances: AbsoluteDistances\\n  ): { displacement: number; alignment: number } {\\n    const areAligned = this.areAligned(this.originRect, candidateRect);\\n\\n    let alignBias = 0;\\n    let orthogonalBias = 0;\\n    let displacement = 0;\\n\\n    switch (this.direction) {\\n      case 'ArrowUp':\\n      case 'ArrowDown':\\n        if (areAligned) {\\n          alignBias = Math.min(intersection.width / this.originRect.width, 1);\\n        } else {\\n          orthogonalBias = this.originRect.width / 2;\\n        }\\n\\n        displacement = (absoluteDistances.x + orthogonalBias) * this.orthogonalWeightVertical;\\n        break;\\n\\n      case 'ArrowRight':\\n      case 'ArrowLeft':\\n        if (areAligned) {\\n          alignBias = Math.min(intersection.height / this.originRect.height, 1);\\n        } else {\\n          orthogonalBias = this.originRect.height / 2;\\n        }\\n\\n        displacement = (absoluteDistances.y + orthogonalBias) * this.orthogonalWeightHorizontal;\\n        break;\\n    }\\n\\n    return { displacement, alignment: alignBias * this.alignWeight };\\n  }\\n\\n  /**\\n   * Calculates the projected intersection between two\\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMRect | rects}.\\n   *\\n   * @param rect1 - First {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMRect | rect}.\\n   * @param rect2 - Second {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMRect | rect}.\\n   *\\n   * @returns The intersection.\\n   * @internal\\n   */\\n  private getIntersection(rect1: DOMRect, rect2: DOMRect): Intersection {\\n    const intersection: Intersection = { width: 0, height: 0, area: 0 };\\n\\n    const topLeftPoint: Point = {\\n      x: Math.max(rect1.left, rect2.left),\\n      y: Math.max(rect1.top, rect2.top)\\n    };\\n    const bottomRightPoint: Point = {\\n      x: Math.min(rect1.right, rect2.right),\\n      y: Math.min(rect1.bottom, rect2.bottom)\\n    };\\n\\n    intersection.width = Math.abs(topLeftPoint.x - bottomRightPoint.x);\\n    intersection.height = Math.abs(topLeftPoint.y - bottomRightPoint.y);\\n\\n    if (topLeftPoint.x < bottomRightPoint.x || topLeftPoint.y < bottomRightPoint.y) {\\n      intersection.area = intersection.width * intersection.height;\\n    }\\n\\n    return intersection;\\n  }\\n\\n  /**\\n   * Checks that both DOMRect are aligned based on the provided direction.\\n   *\\n   * @param rect1 - The first DOMRect.\\n   * @param rect2 - The DOMRect that the first one will be compared to.\\n   *\\n   * @returns If the DOMRect are aligned.\\n   * @internal\\n   */\\n  private areAligned(rect1: DOMRect, rect2: DOMRect): boolean {\\n    return this.direction === 'ArrowLeft' || this.direction === 'ArrowRight'\\n      ? rect1.bottom > rect2.top && rect1.top < rect2.bottom\\n      : rect1.right > rect2.left && rect1.left < rect2.right;\\n  }\\n\\n  /**\\n   * Checks that the first DOMRect is below the second one.\\n   *\\n   * @param rect1 - The first DOMRect.\\n   * @param rect2 - The DOMRect that the first one will be compared to.\\n   *\\n   * @returns If it's below.\\n   * @internal\\n   */\\n  private isBelow(rect1: DOMRect, rect2: DOMRect): boolean {\\n    return (\\n      rect1.top >= rect2.bottom ||\\n      (rect1.top >= rect2.top &&\\n        rect1.bottom > rect2.bottom &&\\n        rect1.left < rect2.right &&\\n        rect1.right > rect2.left)\\n    );\\n  }\\n\\n  /**\\n   * Checks that the first DOMRect is to the right side of the second one.\\n   *\\n   * @param rect1 - The first DOMRect.\\n   * @param rect2 - The DOMRect that the first one will be compared to.\\n   *\\n   * @returns If it's to the right side.\\n   * @internal\\n   */\\n  private isRightSide(rect1: DOMRect, rect2: DOMRect): boolean {\\n    return (\\n      rect1.left >= rect2.right ||\\n      (rect1.left >= rect2.left &&\\n        rect1.right > rect2.right &&\\n        rect1.bottom > rect2.top &&\\n        rect1.top < rect2.bottom)\\n    );\\n  }\\n}\\n\"],\"names\":[],\"mappings\":\"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\"}")}}]);