(window.webpackJsonp=window.webpackJsonp||[]).push([[910],{1189:function(A,e){throw new Error('Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {"version":3,"file":"base-result-image.vue_rollup-plugin-vue=script.js","sources":["../../../../src/components/result/base-result-image.vue?rollup-plugin-vue=script.ts"],"sourcesContent":["\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nimport { Result } from \'@empathyco/x-types\';\\nimport Vue from \'vue\';\\nimport { Component, Prop } from \'vue-property-decorator\';\\nimport { NoElement } from \'../no-element\';\\n\\n/**\\n * Component to be reused that renders an `<img>`.\\n *\\n * @public\\n */\\n@Component({\\n  components: {\\n    NoElement\\n  }\\n})\\nexport default class BaseResultImage extends Vue {\\n  /**\\n   * Animation to use when switching between the placeholder, the loaded image, or the failed\\n   * image fallback.\\n   *\\n   * @public\\n   */\\n  @Prop({ default: () => NoElement })\\n  public animation!: string | typeof Vue;\\n  /**\\n   * The image has entered in the port view.\\n   *\\n   * @public\\n   */\\n  protected hasEnteredView = false;\\n  /**\\n   * An array of images that failed to load.\\n   *\\n   * @public\\n   */\\n  protected failedImages: string[] = [];\\n  /**\\n   * HTMLElement that references the picture element.\\n   *\\n   * @public\\n   */\\n  public $refs!: { image: HTMLElement };\\n  /**\\n   * Indicates if the result image is loaded.\\n   *\\n   * @public\\n   */\\n  protected hasImageLoaded = false;\\n\\n  /**\\n   * (Required) The {@link @empathyco/x-types#Result | result} information.\\n   *\\n   * @public\\n   */\\n  @Prop({ required: true })\\n  protected result!: Result;\\n\\n  /**\\n   * Checks if intersection observer is available in window object.\\n   *\\n   * @returns Boolean.\\n   *\\n   * @internal\\n   */\\n  protected get isIntersectionObserverAvailable(): boolean {\\n    return \'IntersectionObserver\' in window;\\n  }\\n\\n  mounted(): void {\\n    this.hasEnteredView = !this.isIntersectionObserverAvailable;\\n    if (this.isIntersectionObserverAvailable) {\\n      this.createObserver();\\n    }\\n  }\\n\\n  /**\\n   * Gets the src from the result image.\\n   *\\n   * @returns The result image src.\\n   *\\n   * @internal\\n   */\\n  protected get imageSrc(): string {\\n    if (this.hasEnteredView && this.result.images.length > 0) {\\n      const image = this.result.images.find(image => !this.failedImages.includes(image));\\n      return image ?? \'\';\\n    }\\n    return \'\';\\n  }\\n\\n  /**\\n   * Creates an intersection observer in the image element.\\n   *\\n   * @internal\\n   */\\n  protected createObserver(): void {\\n    const image = this.$refs.image as Element;\\n    const observer = new IntersectionObserver(this.observerHandler.bind(this));\\n    observer.observe(image);\\n  }\\n\\n  /**\\n   * Observe all the observables items and detects when a element is intersected.\\n   *\\n   * @param entries - The observed items.\\n   * @param observer - The intersection observer object.\\n   *\\n   * @internal\\n   */\\n  protected observerHandler(\\n    entries: IntersectionObserverEntry[],\\n    observer: IntersectionObserver\\n  ): void {\\n    entries.forEach(entry => {\\n      if (entry.isIntersecting) {\\n        this.hasEnteredView = true;\\n        observer.disconnect();\\n      }\\n    });\\n  }\\n\\n  /**\\n   * Sets an image as failed.\\n   *\\n   * @internal\\n   */\\n  protected flagImageAsFailed(): void {\\n    this.failedImages.push(this.imageSrc);\\n  }\\n\\n  /**\\n   * Checks if all the images failed.\\n   *\\n   * @returns Boolean.\\n   *\\n   * @internal\\n   */\\n  protected get hasAllImagesFailed(): boolean {\\n    return this.failedImages.length === this.result.images.length;\\n  }\\n\\n  /**\\n   * Marks an image as loaded.\\n   *\\n   * @internal\\n   */\\n  protected flagImageLoaded(): void {\\n    this.hasImageLoaded = true;\\n  }\\n}\\n"],"names":[],"mappings":";;;;;AA2CA;;;;;AAUA;IAA6C,mCAAG;IAAhD;QAAA,qEAsIC;;;;;;QAxHW,oBAAc,GAAG,KAAK,CAAC;;;;;;QAMvB,kBAAY,GAAa,EAAE,CAAC;;;;;;QAY5B,oBAAc,GAAG,KAAK,CAAC;;KAsGlC;IArFC,sBAAc,4DAA+B;;;;;;;;aAA7C;YACE,OAAO,sBAAsB,IAAI,MAAM,CAAC;SACzC;;;OAAA;IAED,iCAAO,GAAP;QACE,IAAI,CAAC,cAAc,GAAG,CAAC,IAAI,CAAC,+BAA+B,CAAC;QAC5D,IAAI,IAAI,CAAC,+BAA+B,EAAE;YACxC,IAAI,CAAC,cAAc,EAAE,CAAC;SACvB;KACF;IASD,sBAAc,qCAAQ;;;;;;;;aAAtB;YAAA,iBAMC;YALC,IAAI,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;gBACxD,IAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,UAAA,KAAK,IAAI,OAAA,CAAC,KAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,KAAK,CAAC,GAAA,CAAC,CAAC;gBACnF,OAAO,KAAK,aAAL,KAAK,cAAL,KAAK,GAAI,EAAE,CAAC;aACpB;YACD,OAAO,EAAE,CAAC;SACX;;;OAAA;;;;;;IAOS,wCAAc,GAAxB;QACE,IAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAgB,CAAC;QAC1C,IAAM,QAAQ,GAAG,IAAI,oBAAoB,CAAC,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAC3E,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;KACzB;;;;;;;;;IAUS,yCAAe,GAAzB,UACE,OAAoC,EACpC,QAA8B;QAFhC,iBAUC;QANC,OAAO,CAAC,OAAO,CAAC,UAAA,KAAK;YACnB,IAAI,KAAK,CAAC,cAAc,EAAE;gBACxB,KAAI,CAAC,cAAc,GAAG,IAAI,CAAC;gBAC3B,QAAQ,CAAC,UAAU,EAAE,CAAC;aACvB;SACF,CAAC,CAAC;KACJ;;;;;;IAOS,2CAAiB,GAA3B;QACE,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;KACvC;IASD,sBAAc,+CAAkB;;;;;;;;aAAhC;YACE,OAAO,IAAI,CAAC,YAAY,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC;SAC/D;;;OAAA;;;;;;IAOS,yCAAe,GAAzB;QACE,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;KAC5B;IA7HD;QADC,IAAI,CAAC,EAAE,OAAO,EAAE,cAAM,OAAA,SAAS,GAAA,EAAE,CAAC;sDACI;IAgCvC;QADC,IAAI,CAAC,EAAE,QAAQ,EAAE,IAAI,EAAE,CAAC;mDACC;IAxCP,eAAe;QALnC,SAAS,CAAC;YACT,UAAU,EAAE;gBACV,SAAS,WAAA;aACV;SACF,CAAC;OACmB,eAAe,CAsInC;IAAD,sBAAC;CAAA,CAtI4C,GAAG;;;;"}')}}]);