(window.webpackJsonp=window.webpackJsonp||[]).push([[715],{1486:function(e,n){throw new Error("Module parse failed: Unexpected token (1:10)\nYou may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders\n> {\"version\":3,\"file\":\"search-input.vue.js\",\"sources\":[\"../../../../../src/x-modules/search-box/components/search-input.vue\"],\"sourcesContent\":[\"<template>\\n  <input\\n    ref=\\\"input\\\"\\n    @blur=\\\"emitUserBlurredSearchBox\\\"\\n    @click=\\\"emitUserClickedSearchBox\\\"\\n    @focus=\\\"emitUserFocusedSearchBox\\\"\\n    @input=\\\"emitUserIsTypingAQueryEvents\\\"\\n    @keydown.enter=\\\"emitUserPressedEnterKey\\\"\\n    @keydown.up.down.prevent=\\\"emitUserPressedArrowKey\\\"\\n    :maxlength=\\\"maxLength\\\"\\n    :value=\\\"query\\\"\\n    autocomplete=\\\"off\\\"\\n    class=\\\"x-input x-search-input\\\"\\n    enterkeyhint=\\\"search\\\"\\n    inputmode=\\\"search\\\"\\n    type=\\\"search\\\"\\n    data-test=\\\"search-input\\\"\\n  />\\n</template>\\n\\n<script lang=\\\"ts\\\">\\n  import { Suggestion } from '@empathyco/x-types';\\n  import Vue from 'vue';\\n  import { Component, Prop } from 'vue-property-decorator';\\n  import { XOn } from '../../../components/decorators/bus.decorators';\\n  import { State } from '../../../components/decorators/store.decorators';\\n  import { xComponentMixin } from '../../../components/x-component.mixin';\\n  import { ArrowKey, PropsWithType } from '../../../utils';\\n  import { debounce } from '../../../utils/debounce';\\n  import { DebouncedFunction } from '../../../utils/types';\\n  import { XEventsTypes } from '../../../wiring/events.types';\\n  import { WireMetadata } from '../../../wiring/wiring.types';\\n  import { searchBoxXModule } from '../x-module';\\n\\n  /**\\n   * This component renders an input field that allows the user to type a query. It also reacts to\\n   * query changes through event listening.\\n   *\\n   * @public\\n   */\\n  @Component({\\n    mixins: [xComponentMixin(searchBoxXModule)]\\n  })\\n  export default class SearchInput extends Vue {\\n    public $refs!: { input: HTMLInputElement };\\n\\n    /**\\n     * Maximum characters allowed in the input search.\\n     */\\n    @Prop({ default: 64 })\\n    protected maxLength!: number;\\n\\n    /**\\n     * Allows input autofocus when the search field is rendered.\\n     */\\n    @Prop({ default: true })\\n    protected autofocus!: boolean;\\n\\n    /**\\n     * Enables the auto-accept query after debounce.\\n     */\\n    @Prop({ default: true })\\n    protected instant!: boolean;\\n\\n    /**\\n     * Debounce time for the instant.\\n     */\\n    @Prop({ default: 500 })\\n    protected instantDebounceInMs!: number;\\n\\n    /**\\n     * Keyboard keys to accept the autocomplete suggestion.\\n     */\\n    @Prop({ default: () => ['ArrowRight'] })\\n    protected autocompleteKeyboardKeys!: string[]; // https://keycode.info/\\n\\n    /**\\n     * Event that retrieves the autocomplete suggestion.\\n     */\\n    @Prop({ default: 'QuerySuggestionsChanged' })\\n    protected autocompleteSuggestionsEvent!: PropsWithType<XEventsTypes, Suggestion[]>;\\n\\n    @State('searchBox', 'query')\\n    public query!: string;\\n\\n    /**\\n     * When event {@link XEventsTypes.UserReachedEmpathizeTop} or\\n     * {@link SearchBoxXEvents.UserPressedClearSearchBoxButton}\\n     * are emitted the search in put is focused.\\n     *\\n     * @internal\\n     */\\n    @XOn(['UserReachedEmpathizeTop', 'UserPressedClearSearchBoxButton'])\\n    focusInput(): void {\\n      this.$refs.input?.focus();\\n    }\\n\\n    protected debouncedUserAcceptedAQuery!: DebouncedFunction<[string]>;\\n\\n    /**\\n     * When event {@link XEventsTypes.UserAcceptedAQuery} or\\n     * {@link SearchBoxXEvents.UserClearedQuery} are emitted the pending debounced emit\\n     * {@link XEvent} `UserAcceptedAQuery` is canceled.\\n     *\\n     * @internal\\n     */\\n    @XOn(['UserAcceptedAQuery', 'UserClearedQuery'])\\n    cancelDebouncedUserAcceptedAQuery(): void {\\n      this.debouncedUserAcceptedAQuery?.cancel();\\n    }\\n\\n    mounted(): void {\\n      if (this.autofocus) {\\n        this.focusInput();\\n      }\\n    }\\n\\n    /**\\n     * Emits {@link XEventsTypes.UserAcceptedAQuery} event with a debounce configured in\\n     * `instantDebounceInMs` prop.\\n     *\\n     * @internal\\n     * @param query - The query that will be emitted.\\n     */\\n    emitDebouncedUserAcceptedAQuery(query: string): void {\\n      if (this.instant) {\\n        if (!this.debouncedUserAcceptedAQuery) {\\n          this.debouncedUserAcceptedAQuery = debounce(\\n            this.emitUserAcceptedAQuery.bind(this),\\n            this.instantDebounceInMs\\n          );\\n        }\\n        this.debouncedUserAcceptedAQuery(query);\\n      }\\n    }\\n\\n    /**\\n     * Generates the {@link WireMetadata | event metadata} object omitting the moduleName.\\n     *\\n     * @returns The {@link WireMetadata} object omitting the moduleName.\\n     * @internal\\n     */\\n    protected createEventMetadata(): Omit<WireMetadata, 'moduleName'> {\\n      return {\\n        target: this.$refs.input,\\n        feature: 'search_box'\\n      };\\n    }\\n\\n    /**\\n     * Emits event {@link SearchBoxXEvents.UserBlurredSearchBox} when search box loses focus.\\n     *\\n     * @internal\\n     */\\n    protected emitUserBlurredSearchBox(): void {\\n      this.$x.emit('UserBlurredSearchBox', undefined, { target: this.$refs.input });\\n    }\\n\\n    /**\\n     * Emits event {@link SearchBoxXEvents.UserClickedSearchBox} when user clicks  the search input.\\n     *\\n     * @internal\\n     */\\n    protected emitUserClickedSearchBox(): void {\\n      this.$x.emit('UserClickedSearchBox', undefined, { target: this.$refs.input });\\n    }\\n\\n    /**\\n     * Emits event {@link SearchBoxXEvents.UserFocusedSearchBox} when search box gains focus.\\n     *\\n     * @internal\\n     */\\n    protected emitUserFocusedSearchBox(): void {\\n      this.$x.emit('UserFocusedSearchBox', undefined, { target: this.$refs.input });\\n    }\\n\\n    /**\\n     * Emits event {@link SearchBoxXEvents.UserIsTypingAQuery} when the user typed/pasted something\\n     * into the search-box. Also emits event {@link SearchBoxXEvents.UserClearedQuery} when the user\\n     * removes all characters in the search-box.\\n     *\\n     * @internal\\n     */\\n    protected emitUserIsTypingAQueryEvents(): void {\\n      const query = this.$refs.input.value;\\n      this.$x.emit('UserIsTypingAQuery', query, { target: this.$refs.input });\\n      if (query.trim()) {\\n        this.emitDebouncedUserAcceptedAQuery(query);\\n      } else {\\n        this.cancelDebouncedUserAcceptedAQuery();\\n      }\\n    }\\n\\n    /**\\n     * Emits event {@link XEventsTypes.UserPressedArrowKey} when the user pressed an arrow key.\\n     *\\n     * @param event - The keyboard event with the arrow key pressed.\\n     * @internal\\n     */\\n    protected emitUserPressedArrowKey(event: KeyboardEvent): void {\\n      this.$x.emit('UserPressedArrowKey', event.key as ArrowKey, this.createEventMetadata());\\n    }\\n\\n    /**\\n     * Emits multiple events when the user pressed the enter key.\\n     *\\n     * @remarks\\n     * Emitted events are:\\n     * * {@link SearchBoxXEvents.UserPressedEnterKey}\\n     * * {@link XEventsTypes.UserAcceptedAQuery}\\n     *\\n     * @internal\\n     */\\n    protected emitUserPressedEnterKey(): void {\\n      const query = this.$refs.input.value.trim();\\n      if (query.length > 0) {\\n        this.$x.emit('UserPressedEnterKey', query, this.createEventMetadata());\\n        this.emitUserAcceptedAQuery(query);\\n      }\\n      this.$refs.input?.blur();\\n    }\\n\\n    /**\\n     * Emits {@link XEventsTypes.UserAcceptedAQuery} event.\\n     *\\n     * @remarks It is necessary in a separated method to use it as the parameter of debounce in\\n     * emitDebouncedUserAcceptedAQuery method.\\n     * @internal\\n     * @param query - The query that will be emitted.\\n     */\\n    protected emitUserAcceptedAQuery(query: string): void {\\n      this.$x.emit('UserAcceptedAQuery', query, this.createEventMetadata());\\n    }\\n  }\\n<\/script>\\n\\n<style lang=\\\"scss\\\" scoped>\\n  .x-search-input::-webkit-search-decoration,\\n  .x-search-input::-webkit-search-cancel-button,\\n  .x-search-input::-webkit-search-results-button,\\n  .x-search-input::-webkit-search-results-decoration {\\n    -webkit-appearance: none;\\n  }\\n</style>\\n\\n<docs lang=\\\"mdx\\\">\\n## Events\\n\\nThis component emits the following events:\\n\\n- [`UserClickedSearchBox`](./../../api/x-components.searchboxxevents.md)\\n- [`UserBlurredSearchBox`](./../../api/x-components.searchboxxevents.md)\\n- [`UserFocusedSearchBox`](./../../api/x-components.searchboxxevents.md)\\n- [`UserIsTypingAQuery`](./../../api/x-components.searchboxxevents.md)\\n- [`UserPressedEnterKey`](./../../api/x-components.searchboxxevents.md)\\n- [`UserPressedArrowKey`](./../../api/x-components.xeventstypes.md)\\n- [`UserAcceptedAQuery`](./../../api/x-components.xeventstypes.md)\\n\\n## See it in action\\n\\n\x3c!-- prettier-ignore-start --\x3e\\n:::warning Backend service required\\nTo use this component, the Search service must be implemented.\\n:::\\n\x3c!-- prettier-ignore-end --\x3e\\n\\nHere you have a basic example of how the search input is rendered.\\n\\n_Type any term in the input field to try it out!_\\n\\n```vue\\n<template>\\n  <SearchInput />\\n</template>\\n\\n<script>\\n  import { SearchInput } from '@empathyco/x-components/search-box';\\n\\n  export default {\\n    name: 'SearchInputDemo',\\n    components: {\\n      SearchInput\\n    }\\n  };\\n<\/script>\\n```\\n\\n### Play with props\\n\\nIn this example, the search input has been limited to accept a maximum of 5 characters, including\\nspaces, it won't take the focus when it is rendered, and it will emit the `UserAcceptedAQuery` event\\nafter 1000 milliseconds without typing.\\n\\n_Type a term with more than 5 characters to try it out!_\\n\\n```vue\\n<template>\\n  <SearchInput :maxLength=\\\"5\\\" :autofocus=\\\"false\\\" :instant=\\\"true\\\" :instantDebounceInMs=\\\"1000\\\" />\\n</template>\\n\\n<script>\\n  import { SearchInput } from '@empathyco/x-components/search-box';\\n\\n  export default {\\n    name: 'SearchInputDemo',\\n    components: {\\n      SearchInput\\n    }\\n  };\\n<\/script>\\n```\\n\\n### Play with events\\n\\nIn this example, a message has been added below the search input to illustrate the action performed.\\nFor example, if you select the search input box, the message “focus” appears. When you start to\\nenter a search term, the message “typing” appears. If you press Enter after typing a search term,\\nthe message “enter” appears.\\n\\n_Type any term in the input field to try it out!_\\n\\n```vue\\n<template>\\n  <SearchInput\\n    @UserPressedEnterKey=\\\"logUserPressedEnter\\\"\\n    @UserFocusedSearchBox=\\\"hasFocus = true\\\"\\n    @UserBlurredSearchBox=\\\"hasFocus = false\\\"\\n    @UserIsTypingAQuery=\\\"value = 'focus'\\\"\\n  />\\n</template>\\n\\n<script>\\n  import { SearchInput } from '@empathyco/x-components/search-box';\\n\\n  export default {\\n    name: 'SearchInputDemo',\\n    components: {\\n      SearchInput\\n    },\\n    data() {\\n      return {\\n        value: '',\\n        hasFocus: false\\n      };\\n    },\\n    methods: {\\n      logUserPressedEnter() {\\n        console.log('User pressed enter');\\n      }\\n    }\\n  };\\n<\/script>\\n```\\n\\n## Extending the component\\n\\nComponents can be combined and communicate with each other. Commonly, the `SearchInput` component\\ncommunicates with the [`SearchButton`](x-components.search-button.md) and the\\n[`ClearSearchInput`](x-components.clear-search-input.md) to offer a full query entry experience.\\nFurthermore, you can use it together with the [`QuerySuggestions`](query-suggestions.md) component\\nto autocomplete the typed search term.\\n\\n_Type “puzzle” or another toy in the input field and then click the clear icon to try it out!_\\n\\n```vue\\n<template>\\n  <div>\\n    <div style=\\\"display: flex; flex-flow: row nowrap;\\\">\\n      <SearchInput />\\n      <ClearSearchInput>\\n        <img src=\\\"/assets/icons/cross.svg\\\" />\\n      </ClearSearchInput>\\n      <SearchButton>Search</SearchButton>\\n    </div>\\n    <QuerySuggestions />\\n  </div>\\n</template>\\n\\n<script>\\n  import {\\n    SearchInput,\\n    ClearSearchInput,\\n    ClearSearchButton\\n  } from '@empathyco/x-components/search-box';\\n  import { QuerySuggestions } from '@empathyco/x-components/query-suggestions';\\n\\n  export default {\\n    name: 'SearchInputDemo',\\n    components: {\\n      SearchInput,\\n      ClearSearchInput,\\n      ClearSearchButton,\\n      QuerySuggestions\\n    }\\n  };\\n<\/script>\\n```\\n</docs>\\n\"],\"names\":[\"const\"],\"mappings\":\";;;;;AAEAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\"}")}}]);